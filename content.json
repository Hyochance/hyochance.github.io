{"meta":{"title":"Hyochance IT Blog","subtitle":null,"description":null,"author":"Hyochance","url":"https://hyochance.github.io"},"pages":[],"posts":[{"title":"비동기성(asynchronus)","slug":"Programming/Javascript/181215_asynchronous","date":"2018-12-15T14:45:27.000Z","updated":"2018-12-16T10:37:57.901Z","comments":true,"path":"2018/12/15/Programming/Javascript/181215_asynchronous/","link":"","permalink":"https://hyochance.github.io/2018/12/15/Programming/Javascript/181215_asynchronous/","excerpt":"","text":"Javascript의 가장 도드라지는 특징 Javascript로 코드를 짜는데, 정확히 코드를 작성했음에도 내 의도대로 동작하지 않는다면 비동기성을 의심해보자. 무슨말이냐고? 우선 두 가지 아주 간단한 가정을 하고 코드를 살펴보자. serachGoogle(word) 함수는 이미 완성되어 있으며, 이 함수는 word를 구글에서 검색한 결과를 반영한다.반환값 예): {status_code, data} seachGoogle(word) 함수의 총 실행시간은 2초다.(클라이언트-서버 간 통신시간 포함) 그리고 아래와 같은 파이썬 코드가 있다고 하자.12345678#PYTHONdef main(): result = serachGoogle('Javascript') #1번 문장 print(result) #2번 문장main()#실행결과(2초 뒤) : &#123;'status_code':200, data:'[이런 저런 내용들, ...]'&#125; 1번 문장을 실행한 뒤 그 결과값을 result에 담는다.(처음 가정대로 2초가 소요된다.) 그 후 2번 문장을 실행한다. 너무나 명료해서 이해하기 어렵지 않다. 완벽히 우리가 의도한 순서대로 작동한다. 똑같은 코드를 자바스크립트로 작성해보자. 123456789//JAVASCRIPTfunction main()&#123; let result = serachGoogle('Javascript') //1번 문장 console.log(result) //2번 문장&#125;main()// 실행결과(즉시) : undefined 위의 Python 예제와 완벽히 똑같은 코드임에도 Javascript는 전혀 예상 밖의 결과인 undefined를 반환한다. (2초를 안 기다리고, 즉시 실행하는 것을 눈치챘는가?) 아마 ‘비동기성’과 ‘Javasciprt’ 두 단어를 함께 검색해서 이 글을 읽고 계신 분이라면 비슷한 문제를 겪고 있으리라 짐작된다. 위 실행결과 값이 다른 결정적인 이유는 동기성과 비동기성의 차이에 있다. Python 예제의 경우,1번 문장을 실행한다. -&gt; 2초동안 1번 문장의 결과가 반환되길 기다린다 -&gt; 2번 문장을 실행한다. 그러나 Javascript 예제의 경우,1번 문장을 실행한다. -&gt; 2번 문장을 즉시 실행한다 -&gt; 2초 뒤 1번 문장serachGoogle()의 결과가 도착하나 프로그램은 이미 종료되어있다. 차이가 보이는가? Python은 각 줄의 코드가 끝나길 차분히 기다렸다가 실행한다. 그러나 Javascript는 모든 코드를 쭉 읽어내려가되 기다림이 없다. 그냥 읽기만 하고 모든 코드들을 일단 전부 동작시킨다. 2번 문장이 1번 문장의 결과에 의존적인 코드이지만 Javascript는 그런 것 신경 안 쓴다. CPU가 허용하는 힘껏 문장을 빠르게 읽고 실행시켜버린다. 도대체 왜? Javascript는 하필 왜 이런식으로 작동하는거야? 라는 짜증섞인 의문이 들 수 있다. C, C++, JAVA, PYTHON 등으로 처음 프로그래밍을 시작한 분들의 상식(코드는 작성한 순서대로 차근차근 실행되어야 한다.)에 반하기에 혼란스럽다. 하지만 Javascript는 잘못이 없다. 비동기적인 특징이 필요한 영역들이 있기 때문이다. 페이스북을 생각해보자. 여러분이 스크롤을 내릴때 마다 자동으로 포스트들이 쭉쭉 이어져 ‘무한 스크롤’이 가능해진다. 당연히 페이스북이 처음부터 모든 포스트들을 ‘무한대로’ 불러와서 여러분이 스크롤을 내리기까지 기다렸다가 데이터를 짠하고 보여주지는 않는다. 실제로는 이렇게 작동한다. 스크롤을 내린다. -&gt; 스크롤 위치를 감지해서, 화면의 끝에 도달하기 전 쯤 서버에 요청을 보내 넉넉한 포스트수를 받아온다. -&gt; 화면의 끝에 도달하면 미리 준비한 포스트를 렌더링한다. -&gt; 사용자는 끊김없이 페이스북을 사용한다.(편안) 이 과정의 반복이 ‘무한 스크롤’을 가능하게 한다. 그리고 이 과정이 비동기적으로 일어나지 않는다면, 포스트를 한 20개 내린다. -&gt; 끝에 도달했다. -&gt; 서버에 요청을 보내고 응답을 받기까지 하염없이 멈춰있는 화면을 본다. -&gt; 포스트를 또 20개 내린다. -&gt; 끝에 도달했다. -&gt; 서버에 요청을 보내고 응답을 받기까지 하염없이 멈춰있는 화면을 본다. -&gt; (불편) 오늘날 대부분의 웹은 역동적인(Dynamic) 사용자 경험을 제공하기 위해 비동기적으로 동작한다. 하지만 동기적으로 작동해야하는 코드는 어떡해? 여러분이 Javascript로 무언가를 개발한다면, 외부(웹페이지, REST API 등)로 데이터를 요청하고, 외부에서 데이터가 들어오길 기다렸다가, 그 데이터를 처리하는 코드들을 작성할 일이 많을 것이다. 이 동작들은 이어달리기처럼 앞뒤 순서가 명확하다. 정신없이 달리기만 하는 Javascript를 멈춰세우고 ‘순서대로’ 할 일을 지시하기 위해선, 비동기적인 코드들을 동기적으로 작동하도록 추가 장치를 해야한다. ES6 전에는 callback으로만 해결할 수 있었다. 그러나 ES6 이후 Promise, async, await가 도입되며 지저분한 콜백 지옥에서 가련한 개발자들을 구원했다. Promise, async, await 이 세 단어만으로도 하나의 포스트를 완성할 수 있기 때문에, 자세한 내용은 다음 포스트에서 알아보도록 하자. 맛보기로 위 Javascript 코드를 아래처럼 살짝만 바꾸면, 우리가 의도한 데로 동작한다.123456789//JAVASCRIPTasync function main()&#123; let result = await serachGoogle('Javascript') //1번 문장 console.log(result) //2번 문장&#125;main()// 실행결과(2초 뒤) : &#123;'status_code':200, data:'[이런 저런 내용들, ...]'&#125; 정리 비동기(Asynchronous)는 비순차(non-sequential)와 같다. Javascript는 비동기적인 특징을 갖는다. Javascript에서 코드를 동기적으로 작동시키기 위해선 추가 장치가 필요하다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"https://hyochance.github.io/categories/Programming/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://hyochance.github.io/tags/Javascript/"}]},{"title":"SWEA 5658 보물상자 비밀번호","slug":"1810/181004-SWEA-5658-Treasure-Box-Password","date":"2018-10-04T01:33:11.000Z","updated":"2018-12-08T09:18:23.247Z","comments":true,"path":"2018/10/04/1810/181004-SWEA-5658-Treasure-Box-Password/","link":"","permalink":"https://hyochance.github.io/2018/10/04/1810/181004-SWEA-5658-Treasure-Box-Password/","excerpt":"","text":"코멘트 SWEA 5658 보물상자 비밀번호 문제는 SWEA( https://www.swexpertacademy.com )에서 쉽게 검색할 수 있다.사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 문자열을 잘라서 중복없이 생성하면 있으면 된다.JAVA에서는 Intger.parseInt가 모든 진법들의 수를 자동으로 10진수로 변환해줘서 풀이가 훨씬 편하다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Iterator;import java.util.LinkedList;import java.util.Scanner;import java.util.Set;import java.util.TreeSet;public class SWEA_5658_Treasure_Box_Password &#123; public static void main(String args[]) &#123; Scanner scan = new Scanner(System.in); int T = scan.nextInt(); for(int t = 1; t &lt;= T; t++) &#123; int N = scan.nextInt(); int K = scan.nextInt(); scan.nextLine(); String line = scan.next(); //한변에 있는 문자열의 갯수 int pivot = N / 4; //가능한 모든 16진수를 10진수의 숫자로 변환한 뒤 중복없이 리스트에 저장 LinkedList&lt;Integer&gt; answers = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; pivot; i++) &#123; for(int j = 0; j &lt; 4; j++) &#123; String temp = line.substring(j * pivot, (j+1) * pivot); int tempToInt = Integer.parseInt(temp, 16); if(!answers.contains(tempToInt)) &#123; answers.add(tempToInt); &#125; &#125; //처리 후 문자열 한 칸 돌리기 //ABCD -&gt; DABC와 같이 문자열의 마지막 글자를 떼서 맨 앞에 붙이면 한 칸 돌린 것과 같다 //마지막 문자 String last = line.substring(N-1, N); //나머지 문자들 line = line.substring(0, N-1); //한바퀴 돌린 새로운 문자들 String newLine = last + line; //다음 번 계산을 위해 line에 newLine을 입력시켜준다. line = newLine; &#125; //LinkedList에 들어있는 값들을 정렬하기 위해 Set 집합에 넣어준다. //Set 집합은 요소들을 오름차순으로 자동 정렬해준다. Set&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(answers); Iterator&lt;Integer&gt; setIter = set.iterator(); //Set에서 정렬된 요소들을 순서대로 새로운 LinkedList에 넣는다. LinkedList&lt;Integer&gt; sortedAns = new LinkedList&lt;&gt;(); while(setIter.hasNext()) &#123; sortedAns.add(setIter.next()); &#125; //K번째 큰수는 내림차순에선 K번째이지만, 오름차순에서는 N - k 번째이다. int index = set.size() - K; System.out.println(\"#\" + t + \" \" + sortedAns.get(index)); &#125; scan.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 5656 벽돌깨기","slug":"1810/181003-SWEA-5656-Brick-Out","date":"2018-10-02T22:36:49.000Z","updated":"2018-12-08T09:17:28.698Z","comments":true,"path":"2018/10/03/1810/181003-SWEA-5656-Brick-Out/","link":"","permalink":"https://hyochance.github.io/2018/10/03/1810/181003-SWEA-5656-Brick-Out/","excerpt":"","text":"코멘트 SWEA 5656 벽돌깨기 문제는 SWEA( https://www.swexpertacademy.com )에서 쉽게 검색할 수 있다.사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 참고 : http://organize-study.tistory.com/167 SW 역량테스트 모의 문제중에 정답률이 가장 높아서, 쉽게 도전했다가 큰 코 다친 문제. 재귀함수가 2개나 존재하다보니 프로그램의 실행을 직관적으로 설명하기가 어렵다. 코드 자체가 설명을 대신한다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class SWEA_5656_brick_out &#123; public final static int[] dx = &#123;0, 0, 1, -1&#125;; public final static int[] dy = &#123;1, -1, 0, 0&#125;; public static int N; public static int W; public static int H; public static int[][][] map; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(bf.readLine()); for(int t = 1; t &lt;=T; t++) &#123; String cases = bf.readLine(); StringTokenizer st = new StringTokenizer(cases, \" \"); N = Integer.parseInt(st.nextToken()); W = Integer.parseInt(st.nextToken()); H = Integer.parseInt(st.nextToken()); int sum = 0; int ans = 0; map = new int[N+1][H][W]; for(int h = 0; h &lt; H; h++) &#123; String tempLine = bf.readLine(); StringTokenizer st2 = new StringTokenizer(tempLine, \" \"); for(int w = 0; w &lt; W; w++) &#123; map[0][h][w] = Integer.parseInt(st2.nextToken()); if(map[0][h][w] &gt; 0) sum += 1; &#125; &#125; ans = sum - run(1); System.out.println(\"#\" + t + \" \" + ans); &#125; &#125; public static int run(int depth) &#123; if(depth &gt; N) &#123; return 0; &#125; int ans = 0; for(int w = 0; w &lt; W; w++) &#123; int temp = 0; copyMap(depth); boolean check = false; for(int h = 0; h &lt; H; h++) &#123; if(map[depth][h][w] != 0) &#123; check = true; temp = dfs(depth, h, w); break; &#125; &#125; if(check == false) continue; dropMap(depth); ans = Math.max(ans, run(depth+1) + temp); &#125; return ans; &#125; public static void copyMap(int depth) &#123; for(int w = 0; w &lt; W; w++) &#123; for(int h = 0; h &lt; H; h++) &#123; map[depth][h][w] = map[depth-1][h][w]; &#125; &#125; &#125; public static int dfs(int depth, int h, int w) &#123; int count = 1; int power = map[depth][h][w]; map[depth][h][w] = 0; for(int p = 1; p &lt; power; p++) &#123; for(int d = 0; d &lt; 4; d++) &#123; int nx = w + dx[d] * p; int ny = h + dy[d] * p; if(nx &lt; 0 || ny &lt; 0 || nx &gt;= W || ny &gt;= H || map[depth][ny][nx] == 0) &#123; continue; &#125; count += dfs(depth, ny, nx); &#125; &#125; return count; &#125; public static void dropMap(int depth) &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for(int w = 0; w &lt; W; w++) &#123; for(int h = H-1; h &gt;=0; h--) &#123; if(map[depth][h][w] != 0) &#123; q.add(map[depth][h][w]); map[depth][h][w] = 0; &#125; &#125; for(int h = H-1; h &gt;=0; h--) &#123; if(!q.isEmpty()) &#123; map[depth][h][w] = q.poll(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"BOJ 1525번 Puzzle","slug":"1809/180929-BOJ-1525-Puzzle","date":"2018-09-28T15:11:27.000Z","updated":"2018-12-08T09:16:09.785Z","comments":true,"path":"2018/09/29/1809/180929-BOJ-1525-Puzzle/","link":"","permalink":"https://hyochance.github.io/2018/09/29/1809/180929-BOJ-1525-Puzzle/","excerpt":"","text":"코멘트 BFS 방식을 사용해 풀었다.이 문제는 단계적으로 2차원 배열인 map의 모양이 계속해서 변한다.이 변화하는 상태와 일일이 추적할 수가 없다. 그래서 만일1 0 32 5 16 8 7이라면, 103251687처럼 한줄로 주욱 쓰고, 여기까지 도달한거리 dist를 맵으로 묶어서 저장하면 된다. 예를 들어 처음 상태인1 0 32 5 16 8 7은 103251687, 0이다. 0을 아래로 한칸 내려1 5 32 0 16 8 7 이 됐다면, 153201687, 1이다. 이처럼 한줄로 주욱 쓰려면 start = (start * 10) + map[i][j]; 수식을 활용할 수 있는데, 이를 위해선 0을 9로 바꿔주는 기교가 필요하다. 어차피 0이나 9나 다른 값들과 중복되지 않는 유일한 값이기 때문에 상관 없다. 그럼 153201687에서 숫자 2는 map에서 몇번째 x와 몇번째 y에 위치한 수일까? 이는int x = zeroPos % 3;int y = zeroPos / 3; 식을 활용해서 map[x][y]에서 어디에 위치했는지 알 수 있게 된다. 반대로 map[x][y]는 숫자 153201687에서 몇번째 index에 위치해있을까? index = x + 3 * y 를 통해 index를 알 수 있게 된다. 마지막으로 String 클래스에는 몇 번째 char를 지정해서 다른 char와 바꿔라 식으로 지정할 수 있는 메소드가 없다. 다만 StringBuilder 클래스에는 setCharAt 메소드가 있으므로 이를 활용하도록 한다. 코드 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.HashMap;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class BOJ_1525_Puzzle &#123; //남북동서 public static final int[] dx = &#123;0, 0, 1, -1&#125;; public static final int[] dy = &#123;1, -1, 0, 0&#125;; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = 3; int[][] map = new int[n][n]; int start = 0; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; map[i][j] = scan.nextInt(); if(map[i][j] == 0) &#123; map[i][j] = 9; &#125; start = (start * 10) + map[i][j]; &#125; &#125; scan.close(); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.add(start); HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(start, 0); while(!q.isEmpty()) &#123; int nowNum = q.poll(); if(nowNum == 123456789) &#123; break; &#125; String now = Integer.toString(nowNum); int zeroPos = now.indexOf('9'); int x = zeroPos % 3; int y = zeroPos / 3; for(int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if(nx &gt;= 0 &amp; nx &lt; n &amp; ny &gt;= 0 &amp; ny &lt; n) &#123; StringBuilder next = new StringBuilder(now); //문자열 위치변경 char temp = next.charAt(x+3*y); next.setCharAt(x+3*y, next.charAt(nx+3*ny)); next.setCharAt(nx+3*ny, temp); int num = Integer.parseInt(next.toString()); if (!hashMap.containsKey(num)) &#123; hashMap.put(num, hashMap.get(nowNum)+1); q.add(num); &#125; &#125; &#125; &#125; if(hashMap.containsKey(123456789)) &#123; System.out.println(hashMap.get(123456789)); &#125; else &#123; System.out.println(-1); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"BOJ","slug":"BOJ","permalink":"https://hyochance.github.io/tags/BOJ/"}]},{"title":"BOJ 9019번 문제 DSLR","slug":"1809/180928-BOJ-9019-DSLR","date":"2018-09-28T10:18:38.000Z","updated":"2018-11-18T15:40:02.301Z","comments":true,"path":"2018/09/28/1809/180928-BOJ-9019-DSLR/","link":"","permalink":"https://hyochance.github.io/2018/09/28/1809/180928-BOJ-9019-DSLR/","excerpt":"","text":"코멘트 BFS 방식으로 풀었다. 문제를 풀어도 계속 시간 초과가 나서 머리를 쥐어짰는데 결론은 L과 R연산의 비효율성에 있었다. 나는 1234가 있으면 이걸 문자열화해서 배열에 저장한 뒤 하나하나 for문으로 위치를 바꿔주는 식으로 프로그램을 짰는데 전혀 그럴 필요가 없다. L연산은 int L = (temp % 1000) *10 + temp/1000; R연산은 int R = (temp / 10) + (temp%10)*1000; 이 수식만 생각해낼 수 있으면 된다. 왜 나머지/나누기/곱하기로 접근할 생각을 하지 않았을까. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class BOJ_9019_DSLR &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int T = scan.nextInt(); for(int t = 1; t &lt;= T; t++) &#123; int startNum = scan.nextInt(); int endNum = scan.nextInt(); boolean[] check = new boolean[10000]; String[] commands = new String[10000]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.add(startNum); check[startNum] = true; commands[startNum] = \"\"; while(!q.isEmpty()) &#123; int temp = q.poll(); if(temp == endNum) break; bfs(temp, q, check, commands); &#125; System.out.println(commands[endNum]); &#125; scan.close(); &#125; public static void bfs(int temp, Queue&lt;Integer&gt; q, boolean[] check, String[] commands) &#123; //D연산 int d = temp * 2; if(d &gt; 9999) &#123; d = d % 10000; &#125; if(check[d] == false) &#123; q.add(d); check[d] = true; commands[d] = commands[temp] + \"D\"; &#125; //S연산 int s = temp-1; if(s == -1) s = 9999; if(check[s] == false) &#123; q.add(s); check[s] = true; commands[s] = commands[temp] + \"S\"; &#125; //L연산 int L = (temp % 1000) *10 + temp/1000; if(check[L] == false) &#123; q.add(L); check[L] = true; commands[L] = commands[temp] + \"L\"; &#125; //R연산 int R = (temp / 10) + (temp%10)*1000; if(check[R] == false) &#123; q.add(R); check[R] = true; commands[R] = commands[temp] + \"R\"; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"BOJ","slug":"BOJ","permalink":"https://hyochance.github.io/tags/BOJ/"}]},{"title":"BOJ 1963번 문제 소수 경로","slug":"1809/180927-BOJ-1963-Prime-Number-Count","date":"2018-09-27T11:21:56.000Z","updated":"2018-12-08T09:16:30.580Z","comments":true,"path":"2018/09/27/1809/180927-BOJ-1963-Prime-Number-Count/","link":"","permalink":"https://hyochance.github.io/2018/09/27/1809/180927-BOJ-1963-Prime-Number-Count/","excerpt":"","text":"코멘트 소스코드 작동 개요 모든 소수를 미리 구해놓는다. (isPrime 함수 작성) 자릿수마다 바꿔가며 숫자 number에 대해 아래 판단을 수행한다. 이미 탐색한 노드인가? NO 이 노드는 소수인가? YES 스택에 해당 number를 추가 check[] 배열을 true로 바꿔 이미 탐색한 노드임을 표시 dist[] 배열에 현재 몇 번째 과정을 수행중인지 기록 일단 소수를 구하는 방법은 여러가지 최적화된 방법이 많지만, 나는 그냥 가장 원시적인 방법을 사용했다. 즉 2부터 n까지 모든 수로 나눠보는 방법을 사용했다. 시간/공간 효율적으로 최악이지만 문제에서 주어진 조건 시간 내에 수행할 수 있었으므로 간단하게 작성만 했다. 이후 1자리수, 10자리수, 100자리수, 1000자리수에 대해서 모든 숫자들을 조합해본 뒤, 소수임을 판단했다. 그리고 소수라면 stack에 저장. 주의할건 1000자리수는 1부터 시작해야 된다는 점. 그래서 다른 자리수의 for문은 0부터 시작하지만, 1000자리수만 1부터 시작한다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class BOJ_1963_prime_number_count &#123; static boolean[] primeList = new boolean[10000]; public static void main(String[] args) &#123; //소수 리스트 구하기 for(int i = 1000; i &lt; 10000; i++) &#123; if(isPrime(i)) &#123; primeList[i] = true; &#125; &#125; Scanner scan = new Scanner(System.in); int T = scan.nextInt(); for(int t = 1; t &lt;= T; t++) &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); boolean[] check = new boolean[10000]; int[] dist = new int[10000]; int start = scan.nextInt(); int end = scan.nextInt(); q.add(start); dist[start] = 0; check[start] = true; while(!q.isEmpty()) &#123; int temp = q.poll(); if(temp == end) &#123; break; &#125; bfs(temp, check, dist, q); &#125; System.out.println(dist[end]); &#125; scan.close(); &#125; //소수인지 판별하는 함수. 가장 기본적인 방식을 썼기에 좀 더 최적화 할 수 있다. public static boolean isPrime(int number) &#123; boolean result = true; for(int i = 2; i &lt; number; i++) &#123; if(number % i == 0) &#123; return false; &#125; &#125; return result; &#125; public static void bfs(int number, boolean[] check, int[] dist, Queue&lt;Integer&gt; q) &#123; int[] parseN = new int[4]; int tempNum = number; int tempi = 0; //입력받은 number를 자릿수마다 전부 쪼개서 parseN에 저장한다. while(tempNum &gt; 0) &#123; parseN[tempi] = tempNum % 10; tempNum = tempNum / 10; tempi++; &#125; //1 자리수의 경우 for(int i = 0; i &lt;= 9; i++) &#123; int calNum = parseN[3] * 1000 + parseN[2] * 100 + parseN[1] * 10 + i; if(check[calNum] == false) &#123; if(primeList[calNum] == true) &#123; q.add(calNum); check[calNum] = true; dist[calNum] = dist[number] + 1; &#125; &#125; &#125; //10 자리수의 경우 for(int i = 0; i &lt;= 9; i++) &#123; int calNum = parseN[3] * 1000 + parseN[2] * 100 + i * 10 + parseN[0]; if(check[calNum] == false) &#123; if(primeList[calNum] == true) &#123; q.add(calNum); check[calNum] = true; dist[calNum] = dist[number] + 1; &#125; &#125; &#125; //100 자리수의 경우 for(int i = 0; i &lt;= 9; i++) &#123; int calNum = parseN[3] * 1000 + i * 100 + parseN[1] * 10 + parseN[0]; if(check[calNum] == false) &#123; if(primeList[calNum] == true) &#123; q.add(calNum); check[calNum] = true; dist[calNum] = dist[number] + 1; &#125; &#125; &#125; //1000 자리수의 경우 for(int i = 1; i &lt;= 9; i++) &#123; int calNum = i * 1000 + parseN[2] * 100 + parseN[1] * 10 + parseN[0]; if(check[calNum] == false) &#123; if(primeList[calNum] == true) &#123; q.add(calNum); check[calNum] = true; dist[calNum] = dist[number] + 1; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"BOJ","slug":"BOJ","permalink":"https://hyochance.github.io/tags/BOJ/"}]},{"title":"SWEA 1213 String","slug":"1809/180919-SWEA-1213","date":"2018-09-19T13:03:37.000Z","updated":"2018-11-18T15:39:55.036Z","comments":true,"path":"2018/09/19/1809/180919-SWEA-1213/","link":"","permalink":"https://hyochance.github.io/2018/09/19/1809/180919-SWEA-1213/","excerpt":"","text":"코멘트 주어진 문자열 : Starteatingwellwiththeseeighttipsforhealthyeating,whichcoverthebasicsofahealthydietandgoodnutrition 찾아야할 문자열 : ti일때, 주어진 문자열을 n, n+ti 로 잘라서 찾아야할 문자열과 같은지를 비교하고, 같으면 카운트를 올려주면 된다. 코드 123456789101112131415161718192021222324252627import java.util.Scanner;public class SWEA_1213_String &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); for(int t = 1; t &lt;= 10; t++) &#123; //입력에서 주어지는 테스트 케이스 번호는 필요 없으므로, 한 번 읽어서 포인터를 옮기기만 한다. scan.nextLine(); String toFind = scan.nextLine(); String line = scan.nextLine(); int count = 0; for(int i = 0; i &lt;= line.length()-toFind.length(); i++) &#123; String temp = line.substring(i, i+toFind.length()); if(temp.equals(toFind)) count+=1; &#125; System.out.println(\"#\" + t + \" \" + count); &#125; scan.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 1209 SUM","slug":"1809/180919-SWEA-1209-SUM","date":"2018-09-19T12:52:14.000Z","updated":"2018-12-08T09:15:52.435Z","comments":true,"path":"2018/09/19/1809/180919-SWEA-1209-SUM/","link":"","permalink":"https://hyochance.github.io/2018/09/19/1809/180919-SWEA-1209-SUM/","excerpt":"","text":"코멘트 SWEA-1209 SUM 문제는 SWEA( https://www.swexpertacademy.com )에서 쉽게 검색할 수 있다.사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 2차원 int[][]배열로 숫자 지도를 만든다. 가로, 세로, 대각선(2개방향)을 각각 더한다. 최댓값을 찾는다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.StringTokenizer;public class SWEA_1209_SUM &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); for(int t = 1; t &lt;= 10; t++) &#123; //입력값중 테스트 케이스의 번호를 알려주는 라인은 필요 없으므로 한 번 읽어서 커서를 옮기기만 함. bf.readLine(); int[][] map = new int[100][100]; for(int i = 0; i &lt; 100; i++) &#123; String tempLine = bf.readLine(); StringTokenizer st = new StringTokenizer(tempLine, \" \"); int tempi = 0; while(st.hasMoreTokens()) &#123; map[i][tempi] = Integer.parseInt(st.nextToken()); tempi++; &#125; &#125; LinkedList&lt;Integer&gt; sumList = new LinkedList&lt;&gt;(); //가로더하기 for(int i = 0; i &lt; 100; i++) &#123; int sum = 0; for(int j = 0; j &lt; 100; j++) &#123; sum += map[i][j]; &#125; sumList.add(sum); &#125; //세로더하기 for(int i = 0; i &lt; 100; i++) &#123; int sum = 0; for(int j =0; j &lt; 100; j++) &#123; sum += map[j][i]; &#125; sumList.add(sum); &#125; //대각선더하기(왼쪽위 -&gt; 오른쪽아래) int sum1 = 0; for(int i = 0; i &lt; 5; i++) &#123; sum1 += map[i][i]; &#125; sumList.add(sum1); //대각선더하기(오른쪽위 -&gt; 왼쪽아래) int sum2 = 0; for(int i = 4; i &gt;= 0; i--) &#123; sum2 += map[i][i]; &#125; sumList.add(sum2); //최댓값 찾기 int max = sumList.get(0); for(int i = 1; i &lt; sumList.size(); i++) &#123; if(sumList.get(i)&gt;max) max = sumList.get(i); &#125; System.out.println(\"#\" + t + \" \" + max); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 5356 의석이의 세로로 말해요","slug":"1809/180919-SWEA-5356","date":"2018-09-19T11:49:11.000Z","updated":"2018-11-18T15:39:57.267Z","comments":true,"path":"2018/09/19/1809/180919-SWEA-5356/","link":"","permalink":"https://hyochance.github.io/2018/09/19/1809/180919-SWEA-5356/","excerpt":"","text":"코멘트 문제의 핵심은 조건에서 주어졌는데 문자열의 길이는 15를 넘지 않는다고 한다.그럼 15칸짜리 String 배열 즉, String[] vertical을 선언해서 입력되는 문자열을 하나씩 잘라 넣으면 된다. 예를 들어 ABCDE가 있으면,vertical[0] = “A”;vertical[1] = “B”;vertical[2] = “C”;vertical[3] = “D”;vertical[4] = “E”;가 되고 다음번 입력이 abcde라면 vertical[0] = “Aa”;vertical[1] = “Bb”;vertical[2] = “Cc”;vertical[3] = “Dd”;vertical[4] = “Ee”;와 같은 순서로 문자열이 추가가 된다. 이렇게 되면 공백일 경우도 생각할 필요가 없다.마지막에는 이 vertical[n]을 순서대로 쭈욱 읽어들여오기만 하면 된다. 코드 123456789101112131415161718192021222324252627282930313233import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class SWEA_5356_vertical &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(bf.readLine()); for(int t = 1; t &lt;= T; t++) &#123; String[] vertical = new String[15]; String[] lines = new String[5]; for(int i = 0; i &lt; 5; i++) &#123; lines[i] = bf.readLine(); for(int j = 0; j &lt; lines[i].length(); j++) &#123; String temp = lines[i].substring(j, j+1); if(vertical[j] == null) &#123; vertical[j] = temp; &#125; else &#123; vertical[j] += temp; &#125; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; 15; i++) &#123; if(vertical[i] != null) sb.append(vertical[i]); &#125; System.out.println(\"#\" + t + \" \" + sb); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 1208 평탄화(Flattern) 문제 풀이","slug":"1809/180918-SWEA-1208-Flattern","date":"2018-09-18T06:08:11.000Z","updated":"2018-12-08T09:15:30.817Z","comments":true,"path":"2018/09/18/1809/180918-SWEA-1208-Flattern/","link":"","permalink":"https://hyochance.github.io/2018/09/18/1809/180918-SWEA-1208-Flattern/","excerpt":"","text":"코멘트 SWEA 1208 - 평탄화 문제는 SWEA( https://www.swexpertacademy.com )에서 쉽게 검색할 수 있다. 사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 주어진 덤프 횟수동안 매번 최고값과 최저점을 찾은 후, 최고값 -1, 최저값 +1을 반복해주면 된다. 이를 위해서 findMax와 findMin 함수를 작성하였고, 이 두 함수는 각각 최고값과 최저점이 있는 ‘배열 내 위치(=인덱스)’를 반환한다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Scanner;import java.util.StringTokenizer;public class SWEA_1208_Flattern &#123; public static void main(String[] args) &#123; int T = 10; Scanner scan = new Scanner(System.in); for(int t = 1; t &lt;= T; t++) &#123; int dumpCount = scan.nextInt(); scan.nextLine(); String line = scan.nextLine(); //주어진 숫자들을 numbers 배열에 입력하기 StringTokenizer st = new StringTokenizer(line, \" \"); int[] numbers = new int[st.countTokens()]; int tempi = 0; while(st.hasMoreTokens()) &#123; numbers[tempi] = Integer.parseInt(st.nextToken()); tempi++; &#125; //덤프 수행 for(int i = 0; i &lt; dumpCount; i++) &#123; int maxPivot = findMax(numbers); int minPivot = findMin(numbers); numbers[maxPivot] -= 1; numbers[minPivot] += 1; &#125; int result = numbers[findMax(numbers)] - numbers[findMin(numbers)]; System.out.println(\"#\" + t + \" \" + result); &#125; scan.close(); &#125; static int findMax(int[] numbers) &#123; int max = 0; for(int i = 1; i &lt; numbers.length; i++) &#123; if(numbers[i] &gt; numbers[max]) &#123; max = i; &#125; &#125; return max; &#125; static int findMin(int[] numbers) &#123; int min = 0; for(int i = 1; i &lt; numbers.length; i++) &#123; if(numbers[i] &lt; numbers[min]) &#123; min = i; &#125; &#125; return min; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"비트마스크 java로 구현하기","slug":"1809/180916-BitMask","date":"2018-09-16T09:58:35.000Z","updated":"2018-11-18T15:39:49.417Z","comments":true,"path":"2018/09/16/1809/180916-BitMask/","link":"","permalink":"https://hyochance.github.io/2018/09/16/1809/180916-BitMask/","excerpt":"","text":"비트마스크의 개념적인 설명은 너무나 많기 때문에 실제 구현만 살펴본다. 비트마스크의 연산들은 다음과 같이 표현할 수 있다. a 집합(비트마스크)에 b를 추가할때, a = a | (1 &lt;&lt; b) a 집합에서 b를 삭제할 때, a = a &amp; ~(1 &lt;&lt; b) a 집합에 b가 들어있는지 확인할 때, a = a &amp; (1 &lt;&lt; b) a 집합에 b가 없으면 추가하고, 있으면 삭제, a = a ^ (1 &lt;&lt; number) a 집합에 모든 요소를 추가할 때, 이때 a 비트마스크의 최대길이는 n이라 가정 a = (1&lt;&lt; n) -1 a 집합의 모든 요소를 삭제할 때, a = 0 위 규칙을 활용하면 아래와 같은 BitMask 계산기를 만들 수 있다.bitmask는 int 즉 정수 값을 반환한다. 코드에느 없지만 실제 2진수로 표현된 비트 마스크를 보고 싶다면 String result = Integer.toBinaryString(bitmask); 와 같이 Integer의 toBinaryString 메소드를 활용하면 된다. 1234567891011121314151617181920212223242526272829303132333435public class BitMask &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int bitmask = 0; int TestCase = scan.nextInt(); for(int i = 0; i &lt; TestCase; i++) &#123; String command = scan.next(); if(command.equals(\"add\")) &#123; int number = scan.nextInt(); bitmask = (bitmask | (1 &lt;&lt; number)); &#125;else if(command.equals(\"remove\")) &#123; int number = scan.nextInt(); bitmask = (bitmask &amp; ~(1 &lt;&lt; number)); &#125;else if(command.equals(\"check\")) &#123; int number = scan.nextInt(); int res = (bitmask &amp; (1 &lt;&lt; number)); if(res != 0) System.out.println(1); else System.out.println(0); &#125; else if(command.equals(\"toggle\")) &#123; int number = scan.nextInt(); bitmask = (bitmask ^ (1&lt;&lt;number)); &#125; else if(command.equals(\"all\")) &#123; bitmask = (1&lt;&lt;n) -1; &#125; else if(command.equals(\"empty\"))&#123; bitmask = 0; &#125; &#125; scan.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"https://hyochance.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://hyochance.github.io/tags/자료구조/"}]},{"title":"126번째 이력서를 낸 날을 읽고","slug":"1809/180903-126-resume","date":"2018-09-03T11:24:25.000Z","updated":"2018-11-18T15:39:21.247Z","comments":true,"path":"2018/09/03/1809/180903-126-resume/","link":"","permalink":"https://hyochance.github.io/2018/09/03/1809/180903-126-resume/","excerpt":"","text":"코멘트 도서관에서 우연히 집어들었지만 굉장히 도움이 된 유용한 책이다. 책의 크기도 작고 240페이지 분량의 가벼운 책이지만 정말 핵심내용들만 들어있다. 이 책은 자소서 문항을 이렇게 써라! 면접 필수 답변은 이거다! 식으로 실용적인 내용에 치우쳐있지 않다. 오히려 취업시장 전반을 돌이켜보고, 회사와 지원자 간의 역학구조에 대해서도 생각한다. 이후 성공적인 취업을 위해서 어떤 전략을 가져가야 되는지에 대해 방법론적으로 접근한다. 취업자의 시각에서 몰두하기 보다는, 회사 차원에서 어떻게 생각하는지를 고민해보기를 강조한다. 말이 쉽지 가장 어려운 내용이지만, 친절하고 알아듣기 쉽게 설명해준다. 따라서 좀 더 포괄적으로 적용할 수 있고, 생각과 발전의 여지가 많은 책이다. 문장들 취준생의 경쟁자는 다른 취준생이 아닌 경력사원이다. (취준생이 범하기 쉬운 오류는) 평생 직업이 될 것인지 아닌지 헤아리지 않는다. 취업만으로 성공 혹은 실패를 평가하는 이 사회의 분위기에서 벗어나지 못한다. 취준생들은 대부분 하나의 이상화된 형상에 집착한다. 그 형상을 누가 만들었는지 생각하지 않는다. 자신들이 원하는 기업은 어떤 지원자를 선택하는지, 어떤 방향으로 판단하는지 고민하지 않는다. 취준생은 기업이 요구하는 정보 이상으로 제공하려고 한다. 하지만 그런 접근 방식은 옳지 않다. 잘 아는 바와 같이 기업은 이익 추구가 존재 목적이다. 이익은 최소의 비용으로 최고의 효과를 창출할 때 극대화 된다. 첫번째 칸은 존경하는 인물을 통해 취준생이 갖는 ‘사람을 대하는 관점’을 보고자 하는 것이다. 특정 인물을 존경하는 이유가 해당 기업이 중시하는 사람에 대한 가치관과부합되어야 한다는 점이다. 성장 과정 : 취준생이 갖고 있는 가치관을 파악하기 위함이다. 어떤 가치관이 어떤 사건이나 인물의 영향으로 구축되고 강화되었는지를 알고 싶은 것이다. 성장 과정 : 취준생이 갖고 있는 가치관을 파악하기 위함이다. 어떤 가치관이 어떤 사건이나 인물의 영향으로 구축되고 강화되었는지를 알고 싶은 것이다. 최근 사회 이슈 : 더불어 사는 사회에 대한 관심을 갖고 있는지, 그리고 특정 관심사에 어떤 관점을 갖고 있는지 알기 위함이다. 기업의 업무는 그 어떤 것도 혼자서는 할 수 없다. 이 기업이 중요하게 생각하는 가치가 무엇인지 정확하게 파악할 필요가 있다. 재차 강조하거니와 기업이 정해진 양식에 자기소개를 요구할 때는 각 칸에서 요구하는 질문을 정확히 이해하는 것이 우선이다. 그리고 그 의도에 따라 나는 어떤 관점으로 각기 다른 정보를 차별성있게 작성해야 할 것이지를 충분히 생각하고 작성해야 한다. 이력서는 과거를 기준으로 객관적인 나를 소개한다. 자기소개서는 미래에 관점을 두고 주관적인 나를 소개한다.","categories":[{"name":"Books","slug":"Books","permalink":"https://hyochance.github.io/categories/Books/"}],"tags":[{"name":"독후감","slug":"독후감","permalink":"https://hyochance.github.io/tags/독후감/"}]},{"title":"카카오 1차 예선 - 6번 문제 프렌즈4블록","slug":"1808/180830-kakao-1-6-friends-block","date":"2018-08-29T20:17:38.000Z","updated":"2018-12-08T12:11:41.693Z","comments":true,"path":"2018/08/30/1808/180830-kakao-1-6-friends-block/","link":"","permalink":"https://hyochance.github.io/2018/08/30/1808/180830-kakao-1-6-friends-block/","excerpt":"","text":"코멘트 문제는 https://programmers.co.kr/learn/courses/30/lessons/17679 이 곳에서 확인할 수 있다. 문제 풀이를 위해서 4가지 메서드를 직접 구현했다. 주어진 map에서 Pang으로 사라질 놈들만 표시한 cloneMap을 생성해주는 메서드 Pang으로 사라지는 블럭이 몇개인지 계산하는 메서드 Pang하고 사라질 블록들을 지우는 메서드 지워진 빈칸을 채우기 위해 위 블록들을 떨어뜨려주는 메서드 이후는 그저 1~4까지 작업을 루프걸어서 계속하게 하면 된다. 언제까지? 더이상 Pang하는 블록이 없어질 때 까지. 그럼에도 코드가 전체적으로 아쉽다. 혹시 참고하실 분은 기본적인 아이디어만 따가고 더 깔끔하게 직접 구현해보는게 좋을 것 같다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class FriendsBlock &#123; public static void main(String[] args) &#123; String[] test = &#123;\"CCBDE\", \"AAADE\", \"AAABF\", \"CCBBF\"&#125;; String[] test2 = &#123;\"TTTANT\", \"RRFACC\", \"RRRFCC\", \"TRRRAA\", \"TTMMMF\", \"TMMTTJ\"&#125;; System.out.println(solution(4, 5, test)); System.out.println(solution(6, 6, test2)); &#125; public static int solution(int m, int n, String[] board) &#123; String[][] map = new String[m][n]; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; map[i][j] = board[i].substring(j, j+1); &#125; &#125; String[][] cloneMap = new String[m][n]; //1회차 checkBlock(m, n, map, cloneMap); int sum = pangBlock(m, n, cloneMap); cleanMap(m, n, map, cloneMap); pullDownMap(m, n, map); //2회차 ~ n회차 checkBlock(m, n, map, cloneMap); while(pangBlock(m,n,cloneMap)!=0) &#123; sum += pangBlock(m,n,cloneMap); cleanMap(m, n, map, cloneMap); pullDownMap(m, n, map); checkBlock(m, n, map, cloneMap); &#125; return sum; &#125; //자신을 기준으로 오른쪽, 아래, 오른쪽아래 3가지 칸을 검사해 모두 같다면 cloneMap에 기록 public static void checkBlock(int m, int n, String[][] map, String[][] cloneMap) &#123; for(int y = 0; y &lt; m-1; y++) &#123; for(int x = 0; x &lt;n-1; x++) &#123; if(map[y][x] == null | map[y+1][x] == null | map[y][x+1] == null | map[y+1][x+1] == null) &#123; //null 처리를 위한 부분. 암것두 안함. 그러나 명시해주지 않으면 nullPointException이 일어남. &#125; else if(map[y][x].equals(map[y][x+1]) &amp; map[y][x].equals(map[y+1][x]) &amp; map[y][x].equals(map[y+1][x+1])) &#123; cloneMap[y][x] = \"X\"; cloneMap[y][x+1] = \"X\"; cloneMap[y+1][x] = \"X\"; cloneMap[y+1][x+1] = \"X\"; &#125; &#125; &#125; &#125; //Pang하고 터질 블록들이 몇개인지 카운트 public static int pangBlock(int m, int n, String[][] cloneMap) &#123; int pang = 0; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(cloneMap[i][j] == null) &#123; continue; &#125; else if(cloneMap[i][j].equals(\"X\")) &#123; pang += 1; &#125; &#125; &#125; return pang; &#125; //cloneMap을 초기화하고, map에서도 Pang하고 터진 블록은 \"\"로 빈칸처리 public static void cleanMap(int m, int n, String[][] map, String[][] cloneMap) &#123; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(cloneMap[i][j] == null) &#123; continue; &#125;else if(cloneMap[i][j].equals(\"X\")) &#123; cloneMap[i][j] = null; map[i][j] = \"\"; &#125; &#125; &#125; &#125; //맨아래, 맨오른쪽 블록부터 탐색해서, 본인이 \"\"(빈칸)일 경우, 세로방향에서 자신과 가장 가까운 블록을 떨어뜨린다. public static void pullDownMap(int m, int n, String[][] map) &#123; for(int i = m-1; i &gt;= 0; i--) &#123; for(int j=n-1; j &gt;=0; j--) &#123; if(map[i][j] == null) &#123; continue; &#125;else if(map[i][j].equals(\"\")) &#123; String temp =\"temp\"; for(int k=i; k&gt;=0; k--) &#123; if(map[k][j] == null) &#123; break; &#125; else if(!map[k][j].equals(\"\")) &#123; temp = map[k][j]; map[k][j] = \"\"; break; &#125; else &#123; temp = null; &#125; &#125; map[i][j] = temp; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"KAKAO","slug":"KAKAO","permalink":"https://hyochance.github.io/tags/KAKAO/"}]},{"title":"카카오 1차 예선 - 5번 문제 News Clustering","slug":"1808/180828-kakao-1-5-news-clustering","date":"2018-08-28T12:22:41.000Z","updated":"2018-12-08T09:13:06.434Z","comments":true,"path":"2018/08/28/1808/180828-kakao-1-5-news-clustering/","link":"","permalink":"https://hyochance.github.io/2018/08/28/1808/180828-kakao-1-5-news-clustering/","excerpt":"","text":"코멘트 문제는 https://programmers.co.kr/learn/courses/30/lessons/17677 여기서 확인과 함께 채점도 해볼 수 있다. 중복을 허용하는 다중집합이라는게 낯설어서 문제를 이해하는데 오래 걸렸다.사천성하듯이 str1List와 str2List에서 짝이 맞는 것들은 각각 자기 집합에서 삭제하고, 짝이 맞는 것들은 교집합 List에 추가해주면 된다. 그리고 테스트 케이스 13개중에 2개가 자꾸 통과가 안되서 고친다고 낑낑 대느라 오래 걸렸다. 주어진 문자열을 두자리씩 끊어 만드는 strList가 둘 다 비어있을때 예외처리하는 부분이 없어서 틀린거였다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.ArrayList;public class NewsClustering &#123; public static void main(String[] args) &#123; String str1 = \"FRANCE\"; String str2 = \"french\"; System.out.println(solution(str1, str2)); &#125; public static int solution(String str1, String str2) &#123; ArrayList&lt;String&gt; str1List = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; str2List = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; conList = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; sumList = new ArrayList&lt;&gt;(); String tempStr = \"\"; for(int i = 0; i &lt; str1.length()-1; i++) &#123; tempStr = str1.substring(i, i+2).toLowerCase(); if(tempStr.matches(\"^[a-z]+$\")) &#123; str1List.add(tempStr); &#125; &#125; for(int i = 0; i &lt; str2.length()-1; i++) &#123; tempStr = str2.substring(i, i+2).toLowerCase(); if(tempStr.matches(\"^[a-z]+$\")) &#123; str2List.add(tempStr); &#125; &#125; boolean emptyLists = false; if(str1List.size() == 0 &amp; str2List.size() == 0) &#123; emptyLists = true; &#125; //교집합 만들기 for(int i = 0; i &lt; str1List.size(); i++) &#123; for(int j = 0; j &lt; str2List.size(); j++) &#123; if(str1List.get(i).equals(str2List.get(j))) &#123; conList.add(str2List.get(j)); // str1List와 str2List에서 겹치는 문자열은 conList에 전부 저장 str1List.remove(i); //str1List에서 겹치는 문자열 삭제 str2List.remove(j); //str2List에서 겹치는 문자열 삭제 i--; j = -1; break; &#125; &#125; &#125; //합집합(sumList) 만들기 sumList.addAll(str1List); //교집합 문자열이 삭제된 상태의 str1List sumList.addAll(str2List); //교집합 문자열이 삭제된 상태의 str2List sumList.addAll(conList); //교집합 문자열 float zacquard; if(emptyLists == false) &#123; float con = (float) conList.size(); float sum = (float) sumList.size(); zacquard = (con / sum) * 65536; &#125; else &#123; //str1List와 str2List가 전부 비어있을 경우 zacquard = 65536; &#125; int result = (int) zacquard; return result; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"KAKAO","slug":"KAKAO","permalink":"https://hyochance.github.io/tags/KAKAO/"}]},{"title":"SWEA 1284 수도요금 경쟁","slug":"1808/180822-swea-1284-water-bill","date":"2018-08-22T03:56:28.000Z","updated":"2018-12-08T09:14:10.646Z","comments":true,"path":"2018/08/22/1808/180822-swea-1284-water-bill/","link":"","permalink":"https://hyochance.github.io/2018/08/22/1808/180822-swea-1284-water-bill/","excerpt":"","text":"코멘트 삼성 SW Expert Academy 1284번 문제 - 수도요금 경쟁문제는 SWEA에서 쉽게 검색할 수 있다. 사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 다시보니 입력부분은 단순히 Scanner로 구현하는게 더 편할 것 같다. 코드 123456789101112131415161718192021222324252627282930313233343536373839import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class swea_1284_bill&#123; public static void main(String args[]) throws NumberFormatException, IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for(int i=1; i &lt;= T; i++) &#123; String s = br.readLine(); StringTokenizer st= new StringTokenizer(s, \" \"); int aPrice = Integer.parseInt(st.nextToken()); int bPriceBase = Integer.parseInt(st.nextToken()); int bPriceLimit = Integer.parseInt(st.nextToken()); int bPriceAdd = Integer.parseInt(st.nextToken()); int bPriceTotal = 0; int used = Integer.parseInt(st.nextToken()); int nicePrice = 0; aPrice = aPrice * used; if(used &lt;= bPriceLimit) &#123; bPriceTotal = bPriceBase; &#125; else &#123; bPriceTotal = bPriceBase + (used - bPriceLimit) * bPriceAdd; &#125; if(aPrice &lt; bPriceTotal) &#123; nicePrice = aPrice; &#125; else &#123; nicePrice = bPriceTotal; &#125; System.out.println(\"#\" + i + \" \" + nicePrice); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 1285 돌던지기","slug":"1808/180822-swea-1285-throw-stone","date":"2018-08-22T03:56:28.000Z","updated":"2018-12-08T09:14:14.824Z","comments":true,"path":"2018/08/22/1808/180822-swea-1285-throw-stone/","link":"","permalink":"https://hyochance.github.io/2018/08/22/1808/180822-swea-1285-throw-stone/","excerpt":"","text":"코멘트 삼성 SW Expert Academy 1285번 문제 - 돌던지기문제는 SWEA에서 쉽게 검색할 수 있다. 사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 절대값은 Math.abs(x)로 구한다는 것만 알면 풀이에 크게 무리가 없다. 코드 12345678910111213141516171819202122232425262728293031import java.util.Scanner;public class SWEA_1285_throw_stone &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int T = scan.nextInt(); for(int i = 1; i&lt;=T; i++) &#123; int player = scan.nextInt(); int scores[] = new int[player]; for(int j = 0; j &lt; player; j++) &#123; scores[j] = scan.nextInt(); &#125; int bestScore = Math.abs(scores[0]); int bestPlayer = 0; for(int k = 0; k &lt; player; k++) &#123; if(Math.abs(scores[k]) == bestScore) &#123; bestPlayer++; &#125; else if(Math.abs(scores[k]) &lt; bestScore) &#123; bestScore = Math.abs(scores[k]); bestPlayer = 1; &#125; &#125; System.out.println(\"#\" + i + \" \" + bestScore + \" \" + bestPlayer); &#125; scan.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"리눅스 자주쓰는 명령어 모음","slug":"1808/180822-linux-command","date":"2018-08-21T20:32:47.000Z","updated":"2018-11-18T15:40:49.401Z","comments":true,"path":"2018/08/22/1808/180822-linux-command/","link":"","permalink":"https://hyochance.github.io/2018/08/22/1808/180822-linux-command/","excerpt":"","text":"처음 우분투 깔고 할일 sudo apt update &amp;&amp; sudo apt upgrade 서비스 관련 실행중인 모든 서비스 보기 systemctl list-units –type=service 부팅시 자동 실행하기 systemctl enable service_name.service (예: systemctl enable httpd.service) 서비스 상태 확인하기 systemctl status service_name.service 서비스 시작하기 systemctl start service_name.service 서비스 중지하기 systemctl stop service_name.service 서비스 재시작 하기 systemctl restart service_name.service 사용량 관련 디스크 사용량 df -h 메모리 사용량 free -m 백그라운드 작업 관련 터미널이 꺼져도 실행되는 백그라운드 작업 nohup ./test.sh &amp; 백그라운드 작업확인 ps -ef 백그라운드 작업 종료 kill [pid of test.sh]","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Linux","slug":"Programming/Linux","permalink":"https://hyochance.github.io/categories/Programming/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hyochance.github.io/tags/Linux/"}]},{"title":"카카오 1차 예선 - 3번 문제 Cache","slug":"1808/180820-kakao-1-3-cache","date":"2018-08-20T09:51:56.000Z","updated":"2018-12-08T09:11:11.344Z","comments":true,"path":"2018/08/20/1808/180820-kakao-1-3-cache/","link":"","permalink":"https://hyochance.github.io/2018/08/20/1808/180820-kakao-1-3-cache/","excerpt":"","text":"코멘트 문제는 http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/ 에서 확인할 수 있다. 우선 Jeju, Pangyo -&gt; jeju, pangyo로 모두 소문자로 변환해준다.그리고 LRU 알고리즘에 따라 구현하면 된다.(LinkedList 활용)그렇게 구현한것이 LRUCache 클래스.set 메서드 하나만 직접 구현하면 된다. (java의 LinkedList에서 제공하는 set과는 다르다)이후 LRUCache에서 return하는 “hit”과 “miss”에 따라 소요시간을 더해주면 된다.단 cacheSize가 0일 때는, 모든 입력은 miss처리되어 소요시간 = 도시수 * 5 코드 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.io.IOException;import java.util.LinkedList;import java.util.Scanner;import java.util.StringTokenizer;public class cache &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; Scanner scan = new Scanner(System.in); int cacheSize = scan.nextInt(); //nextInt후에 다음 라인을 읽으려면, scan.nextLine()으로 커서를 옮겨 다음 줄로 가야 한다. scan.nextLine(); String input = scan.nextLine(); //도시들 입력받기 scan.close(); //이하 입력받은 도시들을 규칙대로 잘라 cities[] 배열에 채워 넣는 코드들 StringTokenizer st = new StringTokenizer(input, \", \"); String[] cities = new String[st.countTokens()]; int tempI = 0; while(st.hasMoreTokens()) &#123; String temp = st.nextToken(); temp = temp.substring(1, temp.length()-1); //양 옆의 \"\"를 자르고 temp = temp.toLowerCase(); //자른 문자열을 소문자로 바꿔준다. cities[tempI] = temp; tempI++; &#125; //LRU캐시 생성 LRUCache cache = new LRUCache(cacheSize); int time = 0; //캐시 사이즈가 0일때, hit은 발생하지 않으므로 시간은 무조건 5초씩 증가한다 if(cacheSize == 0) &#123; for(int i =0; i &lt; cities.length; i++) &#123; time +=5; &#125; //캐시 사이즈가 0이 아닌, 일반적인 경우에는 다음과 같다. &#125; else &#123; for(int i = 0; i &lt; cities.length; i++) &#123; String result = cache.set(cities[i]); if(result.equals(\"hit\")) &#123; time += 1; &#125; else &#123; time += 5; &#125; &#125; &#125; System.out.println(time); &#125; public static class LRUCache &#123; //초기화 int capacity; LinkedList&lt;String&gt; cityCached = new LinkedList&lt;String&gt;(); public LRUCache(int capacity) &#123; this.capacity = capacity; &#125; public String set(String city) &#123; //캐시 안에 찾는 도시가 있을때 if(cityCached.contains(city)) &#123; cityCached.remove(city); cityCached.addFirst(city); return \"hit\"; &#125;else &#123; // 캐시 안에 찾는 도시가 없지만, 캐시가 여유 있을 때 if(cityCached.size() &lt;= capacity) &#123; cityCached.addFirst(city); return \"missed\"; // 캐시 안에 찾는 도시가 없고, 캐시도 꽉 찼을 때 &#125; else &#123; //가장 오래된 캐시를 버려버린다. cityCached.removeLast(); cityCached.addFirst(city); return \"missed\"; &#125; &#125; &#125; &#125; &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"KAKAO","slug":"KAKAO","permalink":"https://hyochance.github.io/tags/KAKAO/"}]},{"title":"SWEA 1928 Base64 Decoder","slug":"1808/180819-swea-1928-Base64-Decoder","date":"2018-08-19T13:43:07.000Z","updated":"2018-12-08T09:14:20.803Z","comments":true,"path":"2018/08/19/1808/180819-swea-1928-Base64-Decoder/","link":"","permalink":"https://hyochance.github.io/2018/08/19/1808/180819-swea-1928-Base64-Decoder/","excerpt":"","text":"코멘트 삼성 SW Expert Academy 1928번 문제 - Base64 Decoder문제는 SWEA에서 쉽게 검색할 수 있다. 사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 문제에서 의도한 바는 64비트 디코더를 직접 구현하는(정말로?) 것일지도 모르겠으나, 나는 그냥 java에서 제공하는 유틸을 사용하기로 했다. Base64디코더는 java.util.Base64 디코더 패키지에 들어있다. 이렇게 푸는게 맞나? 싶다. 아마 util을 사용하지 말고, decoder를 직접 구현하길 바라면서 문제에 자세한 조건을 적어놓은듯 한데, 만약 Base64디코더를 직접 구현하는게 문제라면 이게 난이도 D2가 적절한건가? 싶기도 하다. 코드 12345678910111213141516171819import java.util.Base64;import java.util.Scanner;public class swea_1928_base64_decoder &#123; public static void main(String args[]) &#123; Scanner scan = new Scanner(System.in); int T = scan.nextInt(); scan.nextLine(); for(int i = 1; i &lt;= T; i++) &#123; String s = scan.nextLine(); byte[] decode = Base64.getDecoder().decode(s); String output = new String(decode); System.out.println(\"#\" + i + \" \" + output); &#125; scan.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 1926번 369게임","slug":"1808/180819-swea-1926-369game","date":"2018-08-19T13:00:32.000Z","updated":"2018-12-08T09:14:29.025Z","comments":true,"path":"2018/08/19/1808/180819-swea-1926-369game/","link":"","permalink":"https://hyochance.github.io/2018/08/19/1808/180819-swea-1926-369game/","excerpt":"","text":"코멘트 이 문제는 삼성 SW Expert Academy 사이트( https://www.swexpertacademy.com )에서 확인할 수 있다.문제는 SWEA에서 쉽게 검색할 수 있다. 사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 우선 숫자는 int로 받기 보단, String으로 받았다. 숫자를 자릿수 단위로 Parsing해야 하기 때문.만일 39라는 숫자가 있으면 numParsed[2]라는 배열을 만들어서, numparsed[0] = 3, numparsed[1] = 9를 넣는다. 그리고 numparsed[n]을 순회하면서 3이나 6이나 9가 보일때마다 “-“를 StringBuilder에 추가해주면 된다.String에서 제공하는 contains(), length(), substring(), equals()와 같은 기본 함수들을 적절히 활용하면 쉽게 풀 수 있다. 코드 1234567891011121314151617181920212223242526272829import java.util.Scanner;public class swea_1926_369 &#123; public static void main(String args[]) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); scan.close(); StringBuilder sb = new StringBuilder(); for(int i = 1; i &lt;= n; i++) &#123; String number = Integer.toString(i); if(number.contains(\"3\") | number.contains(\"6\") | number.contains(\"9\")) &#123; String[] numParsed = new String[number.length()]; for(int j = 0; j &lt; number.length(); j++) &#123; numParsed[j] = number.substring(j, j+1); if(numParsed[j].equals(\"3\")| numParsed[j].equals(\"6\") | numParsed[j].equals(\"9\")) &#123; sb.append(\"-\"); &#125; &#125; sb.append(\" \"); &#125;else &#123; sb.append(i + \" \"); &#125; &#125; System.out.println(sb.toString()); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"SWEA 1206번 View","slug":"1808/180817-swea-1206","date":"2018-08-17T14:43:39.000Z","updated":"2018-12-08T09:14:35.489Z","comments":true,"path":"2018/08/17/1808/180817-swea-1206/","link":"","permalink":"https://hyochance.github.io/2018/08/17/1808/180817-swea-1206/","excerpt":"","text":"개요 SWEA 1206번 - View 이 문제는 삼성 SW Expert Academy 사이트(https://www.swexpertacademy.com )에서 확인할 수 있다. 문제는 SWEA에서 쉽게 검색할 수 있다. 사이트에서 무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 이 문제는 잘 읽어보기만 해도 쉽게 이해가 된다. 우선 두개의 2차원 배열을 생각했다. 하나는 map[x][y]로 지도정보를 저장하고, 다른 하나는 height[x][0]으로 x좌표의 높이 정보를 저장했다. 기본적인 탐색 방법은 niceView의 조건은 특정 x의 y 위치에서 양옆 두칸에 아무것도 없어야 하므로 (map[x-1][y] == 1 | map[x-2][y] == 1 | map[x+2][y] == 1 | map[x+1][y] == 1 ) 이 조건일때는 pass. 나머지는 전부 조건을 만족하므로 그 때마다 niceView에 1을 더해주면 된다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445 import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class swea_1206_View &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); for(int t = 0; t &lt; 10; t++) &#123; //테스트 케이스는 10개로 고정되어있다. int width = Integer.parseInt(bf.readLine()); int map[][] = new int[width][256]; //전체 지도 int heightSet[][] = new int[width][1]; //x별 높이(height) 정보 String line = bf.readLine(); StringTokenizer st = new StringTokenizer(line); //지도 생성 for(int x = 0; x &lt; width; x ++) &#123; int height = Integer.parseInt(st.nextToken(\" \")); heightSet[x][0] = height; for(int y = 0; y &lt; height; y++) &#123; map[x][y] = 1; &#125; &#125; int niceView = 0; //양옆은 0 0 , ... , 0 0 이므로 탐색할 필요가 없음 for(int x = 2; x &lt; width-2; x++) &#123; int height = heightSet[x][0]; for(int y = 0; y &lt; height; y++) &#123; if(map[x-1][y] == 1 | map[x-2][y] == 1 | map[x+2][y] == 1 | map[x+1][y] == 1) &#123; continue; &#125; else &#123; niceView += 1; &#125; &#125; &#125; System.out.println(\"#\" + (t+1) + \" \" + niceView); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"OPIC 후기","slug":"1808/180816-i-tested-OPIC","date":"2018-08-16T14:18:29.000Z","updated":"2018-11-18T15:40:35.736Z","comments":true,"path":"2018/08/16/1808/180816-i-tested-OPIC/","link":"","permalink":"https://hyochance.github.io/2018/08/16/1808/180816-i-tested-OPIC/","excerpt":"","text":"시험후기 오늘 인천 CBT 센터에서 OPIC 시험을 보고 왔다. 인천 CBT 센터는 굉장히 쾌적한 곳이였다. 적당히 알맞은 책상 사이즈에 앞뒤로 칸막이가 되어있었다. 혹시라도 칸막이가 없고 좌석들이 따닥따닥 붙어있으면 어쩌나 걱정했는데 전혀 아니다. 시험을 위한 최고의 장소였다고 생각한다. 그렇다고 시험 시 다른 사람들의 소리가 전혀 안 들리는 건 아니였다. 1번 문제가 시작하자마자 사람들이 웅얼웅얼하면서 답변하는 소리가 들리는데, 이게 생각보다 사람을 긴장하게 만든다. 마치 달리기 경주를 위해 다같이 라인에 서있다가, 탕소리를 듣고 남들이 뛰어가는걸 지켜보는 느낌이랄까. 뒤쳐지지 않기 위해 나도 페이스를 올려야 된다는 생각이 무의식중에 들었다. 나는 시험때는 긴장을 특히나 많이하니까… 유일하게 열심히 준비한 스크립트가 자기소개 였는데, 갑자기 심장이 쿵쾅 거리고 긴장이 몰려와서 중간에 숨쉬는게 부자연스러울 정도였다. OPIC 시험 칠때 남들을 의식하면 더 긴장된다더니 그게 이 말이구나 싶었다. 2번 문제부터는 헤드셋을 양 귀에 바짝 붙이고 나의 문제에만 집중했다. 사실 바짝 붙인다고 에바 목소리가 커진다거나, 남들의 소음이 차단되는 건 아니지만 그 행동만으로도 집중하는데 도움이 됐다. 내가 선택한 난이도는 4-4고 받았던 질문들은 다음과 같다. 음악을 좋아한다고 했는데 어떤 음악을 들어? 가장 좋아하는 가수는 누구야? 처음 음악을 들었을 때는 언제야? 어렸을 때는 어떤 음악을 들었어? 지금은 어떤 음악을 들어? 언제 그리고 어디서 음악을 들어? 왜 음악을 들어? 너희 나라에서 사람들은 커피숍에서 주로 어떤 일들을 하니? 커피숍들이 최근 몇년간 어떻게 바뀐것 같니? 과거에는 어땠고, 지금은 어떻니? 커피숍에서 있었던 일 중 기억나는 일이 있으면 말해줘. 의사에게 전화해서 예약을 하기 위해 몇가지 질문을 해봐. 갑자기 일이 생겨서 의사와 한 예약을 지킬 수가 없어, 다른 날짜로 예약을 잡기 위해 전화통화를 해봐. 약속(appointment)를 잡았던 경험에 대해서 얘기해줘. 국내여행을 좋아한다고 했는데 어디로 여행 가는 것을 좋아해? 나도 국내여행 가는 것을 좋아해. 나의 국내여행에 대해 몇가지 질문해봐. 나머지 기억 안남 소회 4-4 여서 그랬을까, 나는 질문이 아주 평이한 것들이었다. 대부분이 내가 선택한 주제에서 나온 질문들이었다. OPIC 후기들을 보면 돌발질문들 때문에 망쳤다는 후기들이 많은데, 나는 당황할 만한 돌발질문이 거의 없었다. 한,두 문제 정도? 나는 문제를 더 꼬아서 낼 줄 알았는데 아니였다. 참고서에 나와있는 질문들과 한글자도 틀리지 않은 질문들이 나왔다. 책에 있는 질문들이 그대로 나온거다. 4-4 난이도는 스크립트만 열심히 파도 되는 시험이었다. OPIC참고서를 보면 생각보다 엄청 두껍다. 이 중에서 랜덤하게 질문이 나올테니 스크립트를 일일이 파도 쓸데없는 짓이야 라고 생각했는데, 본인이 선택한 12개의 서베이 주제는 완벽하게 스크립트를 짜볼 필요가 있는 것 같다. 분명 시간 낭비는 아니다. 문제가 한글자도 안틀리고 그대로 나온다. 돌발스럽지도 않았으며, 책에서 본 질문이 똑같이 나왔다. 다시 시험을 친다면, 12개의 서베이 주제에 대해서는 전부 스크립트를 짜는 식으로 공부를 할 것 같다. 높은 점수는 바라지 않는다. 단지 IM2 이상만 나와도 좋겠다.","categories":[{"name":"Personal","slug":"Personal","permalink":"https://hyochance.github.io/categories/Personal/"},{"name":"Essay","slug":"Personal/Essay","permalink":"https://hyochance.github.io/categories/Personal/Essay/"}],"tags":[{"name":"OPIC","slug":"OPIC","permalink":"https://hyochance.github.io/tags/OPIC/"}]},{"title":"SWEA 1204번 최빈수 구하기","slug":"1808/180816-SWEA-1204","date":"2018-08-15T17:17:19.000Z","updated":"2018-12-08T09:05:27.199Z","comments":true,"path":"2018/08/16/1808/180816-SWEA-1204/","link":"","permalink":"https://hyochance.github.io/2018/08/16/1808/180816-SWEA-1204/","excerpt":"","text":"코멘트 삼성 SW Expert Academy 1204번 문제 - 최빈수 구하기.무단 복제를 금지하기 때문에 따로 문제를 올리지는 않는다. 시스템 입력을 받는 bf(BufferdReader) 선언 부에서는 단순히 System.in으로 처리했다. JAVA 콘솔에서 테스트 할 경우에는 약 5010개에 달하는 숫자들을 복붙해야할 수도 있기 때문에 그냥 SWEA 사이트에서 코드를 테스트하길 추천한다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Solution &#123; public static void main(String args[]) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int students = 1000; //학생수 int T = Integer.parseInt(bf.readLine()); //테스트 케이스 개수 String[] nums = new String[T]; //테스트 케이스 번호 for(int i=0; i &lt; T; i++) &#123; int[] scores = new int[101]; //0~100점까지의 배열을 만들고, for(int a=0; a &lt; scores.length; a++) &#123; //그 배열의 값을 전부 0으로 초기화함 scores[a] = 0; &#125; nums[i] = bf.readLine(); String s = bf.readLine(); StringTokenizer st = new StringTokenizer(s); int max = 0; int maxTick = 0; // 각 성적을 차례차례 읽어들여서 해당 성적 배열(scores[])의 카 운트를 1씩 올려줌 for(int k=0; k&lt;students; k++) &#123; int tick = Integer.parseInt(st.nextToken(\" \")); scores[tick] = scores[tick] + 1; &#125; // 모든 배열을 탐색하며 scores[f]의 값이 가장 높은 수를 찾음. 그것이 곧 최빈수. for(int f=0; f&lt;scores.length; f++) &#123; // 같은 빈도로 출현할 경우, 값이 큰 성적을 출력해야 하므로, max&lt;=scores[f] if(max &lt;= scores[f]) &#123; max = scores[f]; maxTick = f; &#125; &#125; System.out.println(\"#\" + nums[i] + \" \" + maxTick); //예 : #1 71 &#125; bf.close(); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"삼성SWEA","slug":"삼성SWEA","permalink":"https://hyochance.github.io/tags/삼성SWEA/"}]},{"title":"BOJ 1003번 피보나치 문제(DP 풀이)","slug":"1808/180814-BOJ-1003-Fibonacci","date":"2018-08-14T11:10:11.000Z","updated":"2018-12-08T09:04:49.769Z","comments":true,"path":"2018/08/14/1808/180814-BOJ-1003-Fibonacci/","link":"","permalink":"https://hyochance.github.io/2018/08/14/1808/180814-BOJ-1003-Fibonacci/","excerpt":"","text":"코멘트 https://www.acmicpc.net/problem/1003 문제는 피보나치 계산을 수행하는 동안 0과 1이 몇번이나 출현하는지를 세어보는 문제였다.연습장에 피보나치 연산트리를 그려보고, 계산과정을 일일이 살펴봤다.너무 많은 케이스를 살필 수 없었기 때문에 5까지만 계산했다. f(0) = 0 f(1) = 1 f(2) = f(1) + f(0) f(3) = f(2) + f(1) = f(1) + f(0) + f(1) = 2f(1) + f(0) f(4) = f(3) + f(2) = f(2) + f(1) + f(2) = 2f(2) + f(1) f(5) = f(4) + f(3) = f(3) + f(2) + f(3) = 2f(3) + f(2) 위의 식에서 알 수 있 듯, 여러번의 계산과 고민을 통해 다음과 같은 규칙을 도출했다. n&gt;2일때, f(n) = 2f(n-2) + f(n-3) 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Boj_1003_Fibonacci2 &#123; public static void main(String args[]) &#123; Scanner scan = new Scanner(System.in); //입력받을 정수의 갯수 int t = scan.nextInt(); //TestCase List int[] tList = new int[t]; for(int i = 0; i &lt; t; i++) &#123; tList[i] = scan.nextInt(); &#125; scan.close(); int[][] nums = new int[41][2]; //f(0), f(1), f(2)의 값은 규칙성이 없다. 따라서 수동으로 값을 지정 nums[0][0] = 1; nums[0][1] = 0; nums[1][0] = 0; nums[1][1] = 1; nums[2][0] = 1; nums[2][1] = 1; for(int i = 0; i &lt; t; i++) &#123; int temp = tList[i]; if(temp == 0 | temp == 1 | temp == 2) &#123; System.out.println(nums[temp][0] + \" \" + nums[temp][1] ); &#125; else &#123; for(int k = 3; k &lt; temp+1; k++) &#123; nums[k][0] = 2 * nums[k-2][0] + nums[k-3][0]; nums[k][1] = 2 * nums[k-2][1] + nums[k-3][1]; &#125; System.out.println(nums[temp][0] + \" \" + nums[temp][1]); &#125; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"BOJ","slug":"BOJ","permalink":"https://hyochance.github.io/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"https://hyochance.github.io/tags/DP/"}]},{"title":"카카오 1차예선 - 2번 문제 Dart게임","slug":"1808/180813-kakao-1-2-question","date":"2018-08-12T17:57:42.000Z","updated":"2018-12-08T09:04:01.809Z","comments":true,"path":"2018/08/13/1808/180813-kakao-1-2-question/","link":"","permalink":"https://hyochance.github.io/2018/08/13/1808/180813-kakao-1-2-question/","excerpt":"","text":"코멘트 문제는 다음 링크에서 확인할 수 있다. http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/참고한 사이트 http://hagnod.tistory.com/467?category=133480 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Dart &#123; public static void main(String args[]) &#123; String case1 = \"1S2D*3T\"; String case2 = \"1S*2T*3S\"; String case3 = \"1D#2S*3S\"; System.out.println(dartScore(case1)); System.out.println(dartScore(case2)); System.out.println(dartScore(case3)); &#125; public static int dartScore(String s) &#123; int result = 0; String[] byDigits = s.split(\"[0-9]+\"); // _, S, D, T String[] byChars = s.split(\"\\\\D+\"); // 1, 2, 3 int score[] = new int[byChars.length]; for(int i=0; i &lt; byChars.length; i++) &#123; score[i] = Integer.parseInt(byChars[i]); if(byDigits[i+1].contains(\"S\")) &#123; score[i] = score[i]; &#125; else if(byDigits[i+1].contains(\"D\")) &#123; score[i] = score[i] * score[i]; &#125; else if(byDigits[i+1].contains(\"T\")) &#123; score[i] = score[i] * score[i] * score[i]; &#125; if(byDigits[i+1].length() &gt;= 2) &#123; if(byDigits[i+1].contains(\"#\")) &#123; score[i] = score[i] * -1; &#125; else if(byDigits[i+1].contains(\"*\")) &#123; if(i &lt; 1) &#123; score[i] = score[i] * 2; &#125; else &#123; score[i-1] = score[i - 1] * 2; score[i] = score[i] * 2; &#125; &#125; &#125; &#125; for(int n : score) &#123; result += n; &#125; return result; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"KAKAO","slug":"KAKAO","permalink":"https://hyochance.github.io/tags/KAKAO/"}]},{"title":"카카오 1차예선 - 1번 문제 비밀지도","slug":"1808/180812-kakao-1-1-question","date":"2018-08-12T14:40:52.000Z","updated":"2018-12-13T09:20:07.760Z","comments":true,"path":"2018/08/12/1808/180812-kakao-1-1-question/","link":"","permalink":"https://hyochance.github.io/2018/08/12/1808/180812-kakao-1-1-question/","excerpt":"","text":"코멘트 문제는 다음 링크에서 확인할 수 있다. http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/ 참고한 풀이 : http://javaplant.tistory.com/3 JAVA의 Integer에서 toBinaryString이라는 메소드를 기본으로 제공해주고 있다. 그러나 위 문제의 조건과 비교하면 한 가지 문제가 있다.예를 들어 9는 1001로 변환되는데, 문제에서 요구하는 것은 01001과 같이 앞에 0을 붙여서라도 n개만큼의 문자열을 요구한다.그래서 코드에 조건문을 좀 더 추가해서 개선했다. 코드 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Scanner;public class Maze2 &#123; public static void main(String args[]) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); Integer[] arr1 = new Integer[n]; Integer[] arr2 = new Integer[n]; for(int i = 0; i &lt; n; i++) &#123; arr1[i] = scan.nextInt(); &#125; for(int i = 0; i &lt; n; i++) &#123; arr2[i] = scan.nextInt(); &#125; scan.close(); String[] result1 = new String[n]; String[] result2 = new String[n]; for(int i = 0; i &lt; n; i++) &#123; result1[i] = Integer.toBinaryString(arr1[i]).replace('0', ' ').replace('1', '#'); result2[i] = Integer.toBinaryString(arr2[i]).replace('0', ' ').replace('1', '#'); /* toBinaryString은 반환된 값 앞에 0을 붙이지 않는다. 예를 들어 9는 1001로 반환한다. 그러나 문제에서 요구하는 것은 숫자가 9여도 01001과 같이 처음입력한 n만큼의 자릿수를 가진 이진수 이기 때문에, toBinaryString으로 변환된 이진수가 n보다 짧다면 그만큼 앞에 0을 붙여줘야한다. 아래는 그 조건문이다. */ if(result1[i].length() &lt; n) &#123; int temp = n - result1[i].length(); for(int k=0; k &lt; temp; k++) &#123; result1[i] = \"0\" + result1[i]; &#125; &#125; if(result2[i].length() &lt; n) &#123; int temp = n - result2[i].length(); for(int k=0; k &lt; temp; k++) &#123; result2[i] = \"0\" + result2[i]; &#125; &#125; &#125; StringBuffer sb = new StringBuffer(); for(int i=0; i &lt; n; i++) &#123; for(int j=0; j &lt; n; j++) &#123; if(result1[i].charAt(j)=='#' || result2[i].charAt(j) =='#') &#123; sb.append('#'); &#125; else &#123; sb.append(' '); &#125; &#125; sb.append(','); &#125; sb.deleteCharAt(sb.length()-1); String result = \"[\"; result = result + sb.toString(); result = result + \"]\"; System.out.println(result); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"},{"name":"KAKAO","slug":"KAKAO","permalink":"https://hyochance.github.io/tags/KAKAO/"}]},{"title":"모든 소수(Prime Number) 구하기","slug":"1808/180810-Prime-Number","date":"2018-08-10T10:20:13.000Z","updated":"2018-11-18T15:40:26.267Z","comments":true,"path":"2018/08/10/1808/180810-Prime-Number/","link":"","permalink":"https://hyochance.github.io/2018/08/10/1808/180810-Prime-Number/","excerpt":"","text":"개요 소수를 구하는 방법들 in JAVA 방법1. 무식한 방법 123456789101112131415161718public class PrimeNumber1 &#123; public static void main(String args[]) &#123; // 탐색범위 int max = 100; for(int n = 2; n &lt;= max; n++) &#123; for(int i = 2; i &lt; n; i++) &#123; // n이 i로 나누어 떨어진다면 소수가 아니므로 탐색을 멈춤 if(n%i == 0) &#123; break; &#125; // n이 바로 직전 수까지도 나누어 떨어지지 않는다면 그 놈은 소수임 if(n == i+1) &#123; System.out.println(n); &#125; &#125; &#125; &#125;&#125; 방법2. 계산 과정에서 얻어진 소수를 활용하는 방법 소수는 본인 이외에 다른 어떤 수로도 나누어 지지 않으므로, 계산 중에 얻은 소수를 배열에 추가하여, 그 배열로 일일이 나누는 방법을 통해 탐색할 수 있다. 또한 모든 짝수는 2로 나누어지므로, 홀수만 탐색하는 것을 기본으로 한다. 12345678910111213141516171819202122232425public class PrimeNumber2 &#123; public static void main(String args[]) &#123; int max = 103; //찾은 소수의 개수 int ptr = 0; //max/2개를 생성해도 됨 int[] pNums = new int[max]; pNums[ptr++] = 2; for(int n=3; n &lt;= max; n+= 2) &#123; for(int i=0; i &lt; ptr; i ++) &#123; if(n % pNums[i] == 0) &#123; break; &#125; if(ptr == i+1) &#123; pNums[ptr++] = n; &#125; &#125; &#125; for (int i = 0; i &lt; ptr; i++) &#123; System.out.println(pNums[i]); &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"https://hyochance.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://hyochance.github.io/tags/알고리즘/"}]},{"title":"OPIC 질문 유형 정리","slug":"1808/180808-OPIC-Question-List","date":"2018-08-07T21:44:52.000Z","updated":"2018-11-18T15:40:24.101Z","comments":true,"path":"2018/08/08/1808/180808-OPIC-Question-List/","link":"","permalink":"https://hyochance.github.io/2018/08/08/1808/180808-OPIC-Question-List/","excerpt":"","text":"인터넷 검색을 토대로, 실제 OPIC 시험 응시자들이 치뤘던 질문들을 정리했다. 돌발질문도 있을 것이고, 여기 있는 질문들이 나온다는 보장은 없다. 그래도 이 질문들을 연습해보는 것도 분명 의미가 있다. 신뢰도를 높이기 위해 최근 1년 이내 후기들만 참고했다. 생활지식이 가장 많다는 네이버 블로그를 위주로 검색하다보니, 광고글들의 유형을 전부 외워버리는 원치 않은 소득도 있었다. 그래도 OPIC이라고 하니 막막했는데, 실제 질문 유형들을 전부 정리해보니 OPIC이 어떤 것을 질문하기 좋아하는지 감이 조금 잡힌 것 같다. 스크립트를 준비할 때 다른 질문들도 이어질 수 있게 준비하라는 말이 이해가 된다. 서베이 기반 질문 음악 듣는 것을 좋아한다고 했는데 언제부터 음악 듣기 시작했어? 과거부터 지금까지 음악 취향이 어떻게 바뀌었는지 설명해줘 좋아하는 가수나 작곡가가 있어? 왜, 언제부터 좋아했어? 그 가수에 대해서도 설명해줘 노래는 보통 언제 들어? 그리고 어떤 방식(기기 등)으로 들어? 가장 좋아하는 국내 여행지에 대해 설명해줘 가장 인상깊었던 여행 장소와 그와 관련된 에피소드를 설명해줘 가장 좋아하는 TV 프로그램을 꼽고, 그 프로그램을 왜 좋아하는지 설명해줘 그 프로그램에서 가장 재미잇게 봤던 에피소드를 설명해줘 그 프로그램에서 가장 최근에 봤던 에피소드를 설명해줘 학교 수업 혹은 직장 근무를 어떤 상황으로 인해 빼야한 적이 있어? 그 경험을 설명해줘 카페가는 것을 좋아한다고 했는데 카페에서 있었던 특별한 경험에 대해 얘기해줘 카페에서 주로 무엇을 하면서 시간을 보내는지 얘기해줘 오늘 날씨에 대해 얘기해줘 너희 나라는 평소 날씨가 어떻니? 너희 나라와 이웃한 나라는 어떤 나라가 있니? 그 나라에 대해 얘기해줘 영화를 좋아한다고 했는데 너가 가장 좋아하는 배우는 누구니? 영화를 보러 가기 전, 보고 난 후 어떤 일들을 하는지 얘기해줘 호텔에 간 경험에 대해 얘기해줘 호텔에서 기억 남는 일이 있었으면 얘기해줘 자주가는 해변에 대해서 묘사해줘 좋아하는 해변에 대해서 묘사해줘 해변에서 있었던 일에 대해서 얘기해줘 너희 나라의 명절에 대해 소개해줘 명절에 가족 혹은 다른 사람들은 어떤 일들을 하니? 인터넷 서핑할 때 주로 어떤 것들을 하니? 돌발질문 너희 나라의 지형에 대해 얘기해줘 너희 나라는 어떤 아웃도어 스포츠를 좋아하는지 말해줘 지금 가지고 있는 휴대폰, 언제 산거야? 너의 폰은 기술적으로 어떤 특징을 가지고 있는지 설명해줘 친구랑 휴대폰에 대해서 얘기할 때 주로 어떤 점들을 평가하는지 얘기해줘 너는 언제 처음으로 휴대폰을 샀니? 왜 샀니? 무슨 기종이니? 살 때 고려한 요소는 무엇이니? 현재의 스마트폰과 과거의 휴대폰의 차이점은 무엇인지 비교해서 설명해줘 지금의 테크놀로지가 과거에 비해 어떻게 발전한 것 같아? 그게 얼마나 어떤 긍정적 요소가 있다고 생각해? 테크놀로지 관련 기사로 최근에 어떤 기사를 읽었는지 설명해줘 집에서 시간을 보내다 기뻤던 일이 있으면 말해줘 너희 집 구조에 대해서 설명해줘 너희 가족들은 집안일을 어떻게 분배해서 맡고 있니? 어릴때 너가 했던 집안일에 대해 설명해줘 너가 재활용을 하는 과정에 대해서 얘기해줘 집에서 어릴 때부터 재활용을 했니? 기억나는 일화가 있으면 말해줘 최근에 재활용 했던 것 중에 기억나는 일화가 있으면 얘기해줘 2명의 뮤지션에 대해서 비교해줘 너희 동네에 유명인사가 왔는데 중요한 얘기가 있었어 이게 뭔지 설명해줄래? 너희 나라의 은행의 모습과 위치, 그리고 자주가는 은행에 대해서 묘사해줘 은행에서 있었던 당황스러운 일들에 대해서 설명해줘 너희 나라에 있는 은행 시스템의 과거와 현재 은행 시스템의 차이를 설명해줘 롤플레이 친구를 집으로 저녁식사 초대하고 싶어. 가족들에게 양해를 구해야하는지, 어떻게 시간 약속을 잡을지 등을 가족들에게 3개 이상 물어봐 그런데 불행하게도 엄마가 아파서 집에서 저녁을 같이 못 먹을 것 같다고 가정해봐. 이럴 때 친구에게 어떻게 말할지 전화통화를 해보고, 새로운 약속을 잡아봐 위의 사례처럼 약속이 있었는데 가족사정이 있어서 못 간적 있어? 있으면 언제 어떤 상황에서 일어났는지, 최종적으로 어떻게 되었는지 얘기해줘 여행 가는 것을 좋아한다고 했지? 나도 여행을 좋아해서 최근에 여행가서 사진도 찍었어. 나에게 이것에 대해 질문 3가지를 해봐 친구에게 mp3를 빌렸는데 너가 실수로 고장을 냈어. 이에 대해 친구와 통화를 해봐 너는 현재 일을 찾는 중이고, 이번에 지원한 회사에 전화해서 인터뷰 세부 일정을 잡는 통화를 해봐 상사가 갑자기 프로젝트를 내일까지 끝내라고 해서, 친구와 같이 GYM가기로 한 약속을 취소해야해. 친구에게 상황을 설명하고 대안을 제시해줘 이제부터 GYM에 새로 등록하려고 하는데 전화해서 어떤걸 물어볼건지 얘기해줘 너가 여행을 가려고 하는데 항공편이 취소됐어, 이 상황에 대해서 여행사에 문의를 해봐 집 창문이 부숴졌는데 수리공에게 전화해서 서비스와 수리 예약을 잡아봐 왜 오늘까지 고쳐야하는지도 설명해줘","categories":[{"name":"Personal","slug":"Personal","permalink":"https://hyochance.github.io/categories/Personal/"},{"name":"Essay","slug":"Personal/Essay","permalink":"https://hyochance.github.io/categories/Personal/Essay/"}],"tags":[{"name":"OPIC","slug":"OPIC","permalink":"https://hyochance.github.io/tags/OPIC/"}]},{"title":"JAVA에서 문자열을 입력/출력하는 방법들","slug":"1808/180808-JAVA-INPUT","date":"2018-08-07T15:47:03.000Z","updated":"2018-11-18T15:40:21.349Z","comments":true,"path":"2018/08/08/1808/180808-JAVA-INPUT/","link":"","permalink":"https://hyochance.github.io/2018/08/08/1808/180808-JAVA-INPUT/","excerpt":"","text":"개요 알고리즘 문제 풀이에 활용하기 위해 JAVA에서 Input을 받는 방법들을 정리해본다. Code Plus의 [프로그래밍 대회에서 사용하는 JAVA - 입출력 맛보기] 강의를 참고했다. 굉장히 유용했다. Scanner 활용 Buffered Reader 활용 String Builder 활용 Scanner 활용 java.util.Scanner 클래스를 활용하는 방법 123456789101112import java.util.Scanner;public class Main&#123; public static void Main(String args[])&#123; Scanner sc = new Scanner(System.in); int a, b; a = sc.nextInt(); b = sc.nextInt(); //Scanner 사용이 끝났다면 닫아주자 sc.close(); System.out.println(a+b); &#125;&#125; Scanner 활용 - 입력에 줄바꿈이 있는 경우(개행문자 : \\n) 예를 들어 입력이 아래와 같을 경우 1hi 1234567891011//! 틀린코드임 !import java.util.Scanner;public class Main&#123; public static void Main(String args[])&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String s = sc.nextLine(); sc.close(); System.out.println(n + \"\\n\" + s); &#125;&#125; 1hi 위와 같이 출력이 되어야 하나 실제로는 1 1만 출력되고 프로그램이 종료되어 버린다. 이는 1이란 숫자 뒤에 개행문자인 \\n을 고려하지 않았기 때문인데 이럴경우 위의 코드에서 123int n = sc.nextInt();sc.nextLine(); //이 코드를 추가String s = sc.nextLine(); sc.nextLine(); 을 한번 실행하여 한 줄 아래의 문장으로 커서를 옮겨주면 된다. BufferedReader Scanner는 사용이 편리하지만, 작동속도가 느리다. 입력이 많을 경우 BufferedReader를 사용하는 것이 좋다. BOJ의 ‘네 수’라는 문제의 풀이를 통해 BufferedReader의 사용법을 살펴보자.https://www.acmicpc.net/problem/10824 123456789101112131415import java.io.*;//io패키지 안에 IOException, BufferedReader, InputStreamReader가 전부 있다.public class Main &#123; public static void main(String[] args) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); //입력값을 공백(spacebar)으로 구분하여, line[]이라는 배열에 각각 집어넣는다. String[] line = bf.readLine().split(\" \"); String a = line[0] + line[1]; String b = line[2] + line[3]; long ans = Long.valueOf(a) + Long.valueOf(b); System.out.println(ans); &#125;&#125; BufferedReader - StringTokenizer 활용 Scanner에는 nextInt()와 같이 정수를 입력받을 수 있었지만, BufferedReader는 next, read, readLine만 있기 때문에 정수는 파싱을 거쳐야 한다. 이럴 때 사용하면 정말 유용한 클래스가 바로 StringTokenizer이다. BOJ의 ‘더하기3’이라는 문제의 풀이를 통해 StringTokenizer의 사용법을 살펴보자.https://www.acmicpc.net/problem/11023 우선 StringTokenizer없이 위의 방법대로만 풀이한 코드다12345678910111213141516import java.io.*;public class Main &#123; public static void main(String args[]) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String line[] = bf.readLine().split(\" \"); int i = 0; int sum = 0; while(i &lt; line.length) &#123; int temp = Integer.parseInt(line[i]); sum += temp; i++; &#125; System.out.println(sum); &#125;&#125; 다음은 StringTokenizer를 활용한 코드다.12345678910111213141516171819import java.io.*;import java.util.*;//StringTokenizer는 java.util 패키지에 들어있다.public class boj_11023 &#123; public static void main(String args[]) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); //line이라는 문자열에 한 줄을 전부 입력받는다. String line = bf.readLine(); //StringTokenizer를 통해 line이라는 String을 토큰(여기서는 공백\" \")으로 구분한다. StringTokenizer st = new StringTokenizer(line); int sum = 0; while (st.hasMoreTokens()) &#123; sum += Integer.valueOf(st.nextToken()); &#125; System.out.println(sum); &#125;&#125; StringTokenizer를 활용할 경우 코드가 좀 더 간결해짐을 알 수 있다. 다음은 콤마(,)로 구분된 입력을 처리하는 방법을 알아보자.BOJ의 ‘더하기’ 라는 문제의 풀이이다.https://www.acmicpc.net/problem/10822 12345678910111213141516import java.io.*;import java.util.*;public class Main &#123; public static void main(String args[]) throws IOException&#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String line = bf.readLine(); //문자열을 자르는 구분자로 \",\" 콤마를 지정해줌 StringTokenizer st = new StringTokenizer(line, \",\"); int sum = 0; while (st.hasMoreTokens()) &#123; sum += Integer.valueOf(st.nextToken()); &#125; System.out.println(sum); &#125;&#125; 위 코드와 크게 다르지 않지만,StringTokenizer st = new StringTokenizer(line, “,”);의 문장을 통해 구분자를 콤마로 지정하여 토큰화하는 부분이 다름을 알 수 있다. 이런식으로 특정 문자열을 지정하며 토큰화할 수 있다. Stirng Builder 출력해야 하는 문자열이 많은 경우에는 String Builder를 통해 출력들을 합쳐 하나의 문자열을 만들고, 출력하는 것이 작동속도면에서 유리하다. 아래는 BOJ의 N찍기 문제의 풀이다. https://www.acmicpc.net/problem/2741 우선 String Builder 없이 기본적으로 풀어본 풀이이다. 123456789101112 import java.util.Scanner;public class Main &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.close(); for(int i=1; i&lt;=n; i++) &#123; System.out.println(i); &#125; &#125;&#125; 이 소스는 BOJ기준 770ms의 소요시간이 걸렸다. 12345678910111213141516import java.util.Scanner;public class Main &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.close(); StringBuilder sb = new StringBuilder(); for(int i=1; i&lt;=n; i++) &#123; sb.append(i + \"\\n\"); &#125; //println이 아닌 print인 것에 유의하자 System.out.print(sb); &#125;&#125; 이 소스는 BOJ기준 252ms의 소요시간이 걸렸다. 위 소스코드보다 거의 3배 이상 빠르게 동작함을 알 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://hyochance.github.io/categories/Programming/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hyochance.github.io/tags/JAVA/"}]},{"title":"JAVA 중급 강의 추천","slug":"1808/180807-JAVA-강의-추천","date":"2018-08-07T14:39:49.000Z","updated":"2018-11-18T15:40:19.119Z","comments":true,"path":"2018/08/07/1808/180807-JAVA-강의-추천/","link":"","permalink":"https://hyochance.github.io/2018/08/07/1808/180807-JAVA-강의-추천/","excerpt":"","text":"인터넷에서 굉장히 유용한 JAVA강의를 발견했다. 이름도 ‘JAVA 중급’이라는 아주 심플한 강의다. 강의 주소 : https://programmers.co.kr/learn/courses/9 목차는 다음과 같다. Object 클래스 java.lang 패키지 java.util 패키지 날짜와 시간 IO 어노테이션 쓰레드 람다 배열, 조건문, 반복문 등 JAVA의 기본을 익힌 후 보면 좋은 강의다. JAVA만의 특징을 더 깊숙히 파고 든다. 개인적으로는 자료구조를 공부하다 java.util에 자료구조가 전부 내장되어 있다는 것을 뒤늦게(…) 깨달은 후, java.util 패키지에 대해 좀 더 검색하다 이 강의를 듣게 됐다. String buffer 등 알고리즘 문제를 JAVA로 푸는데 있어 도움되는 내용들이 많이 있다. 자료구조를 공부한다고 너무 시간을 질질 끌어서는 안 될 것 같다. 하나하나 다 구현해보는 것이 좋긴 하겠지만, 시간이 너무 촉박하므로 모든 자료구조의 원리만 파악한 뒤, 이 강의를 통해서 사용법을 익히고 자료구조는 넘어가야겠다. 얼른 알고리즘 문제를 푸는 것이 시급하다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"JAVA","slug":"Programming/JAVA","permalink":"https://hyochance.github.io/categories/Programming/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hyochance.github.io/tags/JAVA/"}]},{"title":"<JAVA> 연결 리스트(Linked List)","slug":"1808/180806-자료구조-Linked-List","date":"2018-08-06T11:46:27.000Z","updated":"2018-11-18T15:40:12.816Z","comments":true,"path":"2018/08/06/1808/180806-자료구조-Linked-List/","link":"","permalink":"https://hyochance.github.io/2018/08/06/1808/180806-자료구조-Linked-List/","excerpt":"","text":"연결리스트(Linked List)란? 연결리스트는 노드(Node)를 연결해서 만드는 리스트를 뜻한다. 일반적으로 배열을 선얼할 때, 배열의 갯수가 정해진 경우는 많지 않다. 앞으로 배열이 얼마나 크게 늘어날지 알 수 없는 경우가 많은데, 연결리스트는 추가, 삽입, 삭제가 용이 하기 때문에 이런 상황에서 유용하게 활용할 수 있는 자료구조다. 연결리스트(Linked List)의 장점과 단점 장점 배열의 크기를 무한대로 확장할 수 있다. 추가, 삽입,삭제가 가능하다. 단점 속도가 느리다. 예를 들어 마지막 노드를 삭제할 경우, 처음부터 끝까지 순차적으로 탐색해서, 마지막 노드를 찾아낸 뒤 삭제한다. O(N)의 복잡도를 가진다. 소스코드-개요 기본적으로 학습은 오픈튜토리얼스의 이고잉님 강의를 바탕으로 진행했다. (https://opentutorials.org/module/1335/8857). 친절한 설명과 쉬운강의는 이고잉님의 전매특허다. 소스코드는 위 페이지에서도 확인할 수 있고, 개인 github에도 올려두었다.(https://github.com/codingkoo/Algorithm-JAVA/tree/master/algorithm-Java/src/data_structure/list/linkedList) Linked List 클래스의 기능은 다음과 같다. 데이터 추가 첫번째에 노드 추가 마지막에 노드 추가 중간에 노드 추가 데이터 삭제 첫번째 노드 삭제 마지막 노드 삭제 중간 노드 삭제 탐색 반복(학습 생략) LinkedList는 기본적으로 Java Collection Framework에서 지원한다. 코딩 테스트 때 이걸 어떻게 외워서 일일이 구현하지?라는 걱정을 할 필요가 전혀 없다. 1234567import java.util.LinkedListLinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); list.add(\"가위\"); list.add(\"바위\"); list.add(\"보\"); System.out.print(list); 1실행결과 : [가위, 바위, 보] 이런식으로 내장된 LinkedList를 사용할 수도 있지만, LinkedList를 직접 구현해보면서, 고민하고 또 그것들을 해결하는 과정을 통해 배울 수 있는 것이 많았다. Main.java 1234567891011121314151617181920212223package data_structure.list.linkedList;import java.util.Collections;public class Main &#123; public static void main(String[] args) &#123; LinkedList numbers = new LinkedList(); numbers.addFirst(30); numbers.addFirst(20); numbers.addFirst(10); numbers.addLast(10); numbers.addLast(20); numbers.addLast(30); numbers.add(2, 25); numbers.add(6, 35); numbers.removeFirst(); numbers.remove(4); System.out.println(numbers); System.out.println(numbers.get(2)); System.out.println(numbers.indexOf(25)); System.out.println(numbers.indexOf(75)); &#125;&#125; LinkedList.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173package data_structure.list.linkedList;import java.util.ListIterator;public class LinkedList &#123; private Node head; private Node tail; private int size = 0; // Node 객체 선언 private class Node&#123; private Object data; private Node next; public Node(Object input) &#123; this.data = input; this.next = null; &#125; public String toString() &#123; return String.valueOf(this.data); &#125; &#125; //-------추가 관련 메서드 // Node List의 처음에 Node를 추가하는 메서드 public void addFirst(Object input) &#123; Node newNode = new Node(input); newNode.next = head; head = newNode; size++; if(head.next == null) &#123; tail = head; &#125; &#125; // Node List의 마지막에 Node를 추가하는 메소드 public void addLast(Object input) &#123; Node newNode = new Node(input); if(size == 0) &#123; addFirst(input); &#125; else &#123; tail.next = newNode; tail = newNode; size++; &#125; &#125; //index 번째에 있는 Node 객체를 뽑아내는 메소드(내부에서만 사용하기 때문에 public을 붙이지 않음) Node node(int index) &#123; Node x = head; for(int i=0; i &lt; index; i++) &#123; x = x.next; &#125; return x; &#125; // Node List 사이에 노드를 추가하는 메서드 public void add(int index, Object input) &#123; if(index == 0) &#123; addFirst(input); &#125; else &#123; Node aheadOne = node(index-1); Node behindOne = aheadOne.next; Node newNode = new Node(input); aheadOne.next = newNode; newNode.next = behindOne; size++; //만일 제일 끝에 추가한다면 if(newNode.next == null) &#123; tail = newNode; &#125; &#125; &#125; // -------Util성 메소드 // Linked List를 하나의 String으로 반환하는 함수 public String toString() &#123; // 빈 리스트라면 if( head == null) &#123; return \"[]\"; &#125; Node temp = head; String str = \"[\"; //Linked리스트를 전부 순차적으로 탐색 while(temp.next != null) &#123; str += temp.data + \", \"; temp = temp.next; &#125; //마지막 Node는 수동으로 데이터를 1번 추가해줌 str += temp.data; return str + \"]\"; &#125; // -------삭제 관련 메소드 // 첫번째 Node를 삭제하는 메소드 // JAVA에서는 Remove를 했을 때, 삭제된 Node가 갖고 있었던 값을 돌려주게 되어있다. 따라서 Object를 반환. public Object removeFirst() &#123; Node temp = head; head = head.next; //JAVA의 규칙에 따라 돌려주기 위한 데이터를 Object Type으로 저장 Object returnData = temp.data; temp = null; size--; return returnData; &#125; // 특정한 위치의 Node를 삭제하는 메소드 public Object remove(int index) &#123; if(index == 0) &#123; return removeFirst(); &#125; Node temp = node(index-1); Node todoDeleted = temp.next; temp.next = temp.next.next; Object returnData = todoDeleted.data; //만일 삭제하려는 노드가 가장 마지막 노드라면 if(todoDeleted.next == tail) &#123; tail = temp; &#125; todoDeleted = null; size--; return returnData; &#125; // 마지막 Node를 삭제하는 메소드 public Object removeLast() &#123; return remove(size-1); &#125; // ------ 엘리먼트 관련 메소드 //엘리먼트의 크기 public int size() &#123; return size; &#125; //엘리먼트 가져오기 public Object get(int index) &#123; Node temp = node(index); return temp.data; &#125; // ------ 탐색 관련 메소드 public int indexOf(Object data) &#123; Node temp = head; int index = 0; while(temp.data != data) &#123; temp = temp.next; index++; //가장 끝에 있는 node에 도달했을 경우 : 없는 값이여서 못 찾았을 경우 if(temp == null) &#123; //-1을 return해서 검색을 종료시킴 return -1; &#125; &#125; return index; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://hyochance.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"https://hyochance.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://hyochance.github.io/tags/자료구조/"}]},{"title":"오픽 사전설문(OPIC BACKGROUND SURVEY) 준비 전략","slug":"1808/180806-OPIC-SURVEY-준비전략","date":"2018-08-06T05:15:36.000Z","updated":"2018-11-18T15:40:16.511Z","comments":true,"path":"2018/08/06/1808/180806-OPIC-SURVEY-준비전략/","link":"","permalink":"https://hyochance.github.io/2018/08/06/1808/180806-OPIC-SURVEY-준비전략/","excerpt":"","text":"왜 OPIC BACKGROUND SURVEY를 전략적으로 해야할까우선 OPIC은 하나의 시험이다. 회화능력을 측정한다고 해서, 화면 너머의 EVA에게 자신의 모든 것을 솔직하게 털어놓을 필요는 없다. OPIC에는 ‘솔직’이라는 단어가 없다. Background Survey에서 전략적으로 항목들을 선택하지 않는다면, 안 그래도 준비해야할 범위가 많은데 무한대로 범위만 늘어나게 된다. 물론, 정말 회화 공부를 하는 심정으로 앞으로도 오래오래 EVA와 즐거운 OPIC 테스트를 즐길 사람이라면(시험 비용도 만만치 않은데…) 솔직하게 체크하고, 그때그때 관심있는 주제를 선택할 수도 있겠지만, 대부분은 취업 준비를 위한 자격증 취득이 1차 목표일테니, Background Survey를 전략적으로 선택할 수 밖에 없다. 즉, 본인의 성격과 관심사를 여실히 드러내기 보단, 시험에 유리한 하나의 AVATAR를 설정해서 임하는게 훨씬 수월하다. OPIC BACKGROUND SURVEY 준비 전략 현재 귀하는 어느 분야에 종사하고 계십니까? 일 경험 없음 : 다른 항목을 선택하는 순간 직장에 관한 모든 질문 공격을 받게 된다. 현재 귀하는 학생이십니까? 아니오 : 현재 학교, 학업, 친구 등등 교문을 통과하고 들어간 이후 목격할 수 있는 모든 것에 관한 질문 공격을 받게 된다. 예전에 들었던 강의 목적은 무엇입니까? 수강후 5년 이상 지남 : 수업에 관련된 모든 질문을 차단한다. 현재 귀하는 어디에 살고 계십니까? 개인주택이나 아파트에 홀로 거주 : 아무리 부모님과 함께 살더라도, 시험을 위해서 나는 자취생이다 자기최면을 걸고 임하도록 하자. 귀하는 여가 활동으로 주로 무엇을 하십니까?(두 개 이상 선택) 공연보기, 콘서트보기 : 공연과 콘서트는 겹치는 표현이 많다. 공원가기, 해변가기 : 해변과 공원 모두 산책, 운동 등으로 겹치는 표현이 많다. 술집/바에 가기, 카페/커피 전문점 가기 : 가게에 가서 음료를 마신다는 점에서 공통점이 많다. SNS에 글 올리기 : 카톡도 SNS다. 대화소재가 많고, 스마트폰, 인터넷과 같이 묶을 수도 있다. 쇼핑하기, 영화보기 : 영화관은 주로 쇼핑센터에 위치해있다. 겹치는 표현이 많다. 귀하의 취미나 관심사는 무엇입니까?(한 개 이상 선택) 음악 감상하기 : 공연, 콘서트와 겹치는 표현이 있고, SNS에 글올리기와 연계할 수도 있다.(주로 음악에 대해 포스팅을 한다 등). 연계하지 않더라도 음악에 대해선 누구나 할 말이 있는 주제. 귀하는 주로 어떤 운동을 즐기십니까?(한 개 이상 선택) 운동을 전혀 하지 않음 : 운동에 관한 질문은 차단해버리자 당신은 어떤 휴가나 출장을 다녀온 경험이 있습니까?(한 개 이상 선택) 국내여행 : 위에서 선택한 해변가기와 연계할 수 있다. 우리나라는 해변이 많으니까! 모두가 같은 문항을 체크하면 불리하지 않을까? 이와 같은 의문을 가질 수도 있지만, 전국의 OPIC학원에서 위와 똑같거나 거의 비슷한 전략을 가르치고 있기 때문에, 대부분의 OPIC 지원자의 BACKGROUND SURVEY는 위에서 제시한 전략과 같다. 그리고 변별력 강화를 위해 OPIC 측에서 ‘돌발’질문 이란 것을 던지기 때문에, 사실상 판가름은 여기서 난다고 본다. ‘돌발’질문은 말그대로 돌발질문 이기 때문에 어떤 분야에 대해 어떤 질물을 할지 알 수 없다. 예측 불가능한 부분은 포기하더라도, 예측 가능한 부분은 변수를 최소화해서 기본을 가져가는게 더 옳다고 보인다.","categories":[{"name":"Personal","slug":"Personal","permalink":"https://hyochance.github.io/categories/Personal/"},{"name":"Essay","slug":"Personal/Essay","permalink":"https://hyochance.github.io/categories/Personal/Essay/"}],"tags":[{"name":"OPIC","slug":"OPIC","permalink":"https://hyochance.github.io/tags/OPIC/"}]},{"title":"<나는 대한민국 트레이더다> 를 읽고","slug":"1808/180804-나는-대한민국-트레이더다를-읽고","date":"2018-08-04T13:19:05.000Z","updated":"2018-11-18T15:40:08.687Z","comments":true,"path":"2018/08/04/1808/180804-나는-대한민국-트레이더다를-읽고/","link":"","permalink":"https://hyochance.github.io/2018/08/04/1808/180804-나는-대한민국-트레이더다를-읽고/","excerpt":"","text":"우선 책 링크는 다음과 같다https://book.naver.com/bookdb/book_detail.nhn?bid=7114499 이 책은 이미 명저로 자리잡은 외국의 &lt;주식시장의 마법사들&gt; 시리즈를 한국에 맞게 적용한 한국판 &lt;주식시장의 마법사들&gt;이라는 느낌이 강했다. 이 책이 2013년에 쓰여졌으니, 벌써 5년이 지났으니까 내용이 조금 시대에 뒤쳐진다는 느낌도 받았지만, 그 구성과 핵심이 탄탄해서 지금 읽어도 손색없다. 여담이지만 저자는 5년 뒤(그러니까 올해), 시리즈처럼 새로운 편을 또 쓰고 싶다고 했는데 감감 무소식인걸 그 결심은 엎어진 것 같다. 이 책은 KOSPI 선물/옵션, ELS, ELW, HFT 시스템 트레이더 등등 증권사 트레이딩 부서에 존재하는 다양한 시장의 트레이더들을 인터뷰하고 정리한 책이다. 이 책에서 다루는 매 인터뷰는 공통적으로 성공한 트레이더가 되기까지의 여정, 트레이딩 전략, 트레이딩 원칙, 조언 4가지로 구성되어 있다. 슬픈점은 트레이딩 전략의 경우, 거의 이해하지 못하고 글자만 읽어 내려가서 실질적인 도움을 받지 못했다. 나는 선물/옵션을 하지도 않고 ELS와 ELW의 차이점도 모르며, 스프레드 거래가 무엇인지, 베이시스는 또 뭔지 알쏭달쏭할 뿐이기 때문에 이 책에서 소개하는 전략들에서 어떤 영감도 받을 수가 없었다. 소귀에 경읽기랄까. 그래도 각 개개인들의 성공적인 트레이더가 되기 위한 여정과 원칙 부분은 굉장히 재미있게 읽었다. 이 분들의 원칙은 결국 ‘철저한 손절매’인데, 손절매를 지키지 못할 경우, 개인은 치명적인 손실을 스스로 감당하는 선(?)에서 마무리 되지만, 이 분들은 직장도 잃고, 미래도 잃고, 돈도 잃고, 말그대로 삶에서 퇴출당해버리는 기관투자가이기 때문에 ‘철저한 손절매’를 강조할 수 밖에 없는 것 같다. 그리고 이렇게 뛰어난 사람들도 포지션 규모조절에 실패하거나, 손절매 원칙을 지키지 않거나 하는 등 욕심을 부리면 철저하게 깨진다는 사실을 읽으며, 위안 아닌 위안을 받았다. 사람이라면 누구나 이런 실패를 겪게 되는 것이구나. 성공한 트레이더라고 귀신처럼 모든 예외상황을 피해가는 능력이 있는 건 아니다. 넘사벽이 느껴져 스스로 절망했던 점은, 이분들은 대체로 학문적 베이스가 상당히 뛰어난 똑똑한 수재들이란 점이다. 이들은 쏟아지는 금융정보를 수학적으로 분석해서, 상황을 객관적으로 수치화하고 이것들을 바탕으로 세부적으로 전략을 조정할 수 있는 능력이 있다. 말이 쉽지, 나에게는 요원해보이는 일이다. 시장 동향 분석과 전략 분석/테스팅 등으로 아마 이분들은 밤낮없이 바쁘겠지. 그만한 치열함이 개인들에게 있을까? 갈수록 금융시장은 개인이 살아남을 만한 시장이 아닌 것 같다는 생각이 확고해진다. 개인이 돈을 벌면서 꾸준히 살아남을 수 있을까? 대부분은 ‘유동성 공급’의 역할만 충실히하고 사라진다. 서점에 가면 주식으로 벌었다는 고수들의 얘기가 넘치지만, 통계적으로 보면 정말 예외의 아웃라이어들이 아닐까. 그들이 했다고 나라고 할 수 있을까 하는 회의감이 든다. 시장을 이기려 하지 않고, 이런 기관투자가들을 이기려하지 않고, 그 기류에 잘 편승해서 약삭 빠르게 먹으면 되지 않을까. 이렇게 하면 생존과 동시에 수익도 거머쥘 수 있지 않을까 생각했는데 말그대로 탁상공론이자 공불염이다. 말이 쉽지… 이 책을 통해 대한민국 트레이더들의 전문적이고도 치열한 삶을 간접적으로 엿보며 많은 영감을 받았다. 그 영감을 요약하면 비관적이지만 ‘나는 트레이딩을 해서 성공할 자신이 없다.’ 정도… 그래도 현실적인 결론일 것 같다. 금융시장에서 희망 가득찬 무모한 도전은 그저 돈을 뺏길 뿐이니까.","categories":[{"name":"Books","slug":"Books","permalink":"https://hyochance.github.io/categories/Books/"}],"tags":[{"name":"독서","slug":"독서","permalink":"https://hyochance.github.io/tags/독서/"}]}]}